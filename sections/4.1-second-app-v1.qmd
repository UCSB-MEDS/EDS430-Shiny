---
format: revealjs
---

##  {#build-app2 data-menu-title="~~~ Building App #2 ~~~" background="#053660"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">{{< fa tools title="a wrench and screwdriver" >}} Building out your 2<sup>nd</sup> app</p>
<p class="caption-text">*Up until now, we've been adding our text and widgets in a pretty unstructured way -- elements are stacked on top of one another within a single column. Next, we'll learn how to customize the layout of our app to make it a bit more visually pleasing.*</p>
</div>

---

##  {#LO-app2v1 data-menu-title="Learning Objectives - App #2v1"}

[{{< fa book-open title="an open book" >}} Learning Objectives - App #2v1 (two-file app)]{.slide-title}

<hr>

<p class="body-text-l teal-text bottombr">By the end of building out this second app, you should:</p>

. . . 

<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text}` be comfortable creating a shiny app using the two-file (`ui.R` & `server.R`) format along with a `global.R` file</p>

. . .

<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} understand how to use layout functions to customize the visual structure of your app's UI</p>

. .  .

<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} have more practice building reactive outputs -- and placing them within the layout structure of your app</p>

. .  .

<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} be able to create multiple inputs that control a given output</p>

. . . 

<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} know how to import larger bodies of text using `includeMarkdown()` (rather than writing & styling text within your UI)</p>

. . . 

<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} successfully publish an app using [shinyapps.io](https://www.shinyapps.io/)</p>

. . .

<p class="body-text-l teal-text topbr">Packages introduced:</p> 

. . .

<p class="body-text-s">[{{< fa box-open title="an open box" >}}]{.teal-text} `{shinyWidgets}`: extend shiny widgets with some different, fun options</p>

. . .

<p class="body-text-s">[{{< fa box-open title="an open box" >}}]{.teal-text} `{lterdatasampler}`: data</p>

---

##  {#roadmap-app2v1 data-menu-title="Roadmap App #2v1"}

[Roadmap for App #2v1]{.slide-title2}

<hr>

<p class="body-text">We'll be building out our **two-file app** using data from the `{lterdatasampler}` and `{palmerpenguins}` packages. We'll focus on creating a functional app that has a more visually pleasing UI layout (and we'll refine it's appearance even further in [v2]()). By the end of v1, we'll have created:</p>

:::: {.columns}

::: {.column width="45%"}
<br>
<p class="body-text-s">**(a)** A navigation bar with two pages, one of which will contain two tabs (one tab for each plot)</p>
<p class="body-text-s">**(b)** A `pickerInput` *and* `checkboxGroupButtons` for users to filter cutthroat trout data in a reactive scatterplot</p>
<p class="body-text-s">**(c)** A `pickerInput` for users to filter penguin data *and* a `sliderInput` to adjust the number of bins in a reactive histogram</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<br>
<center><img src="images/app2_v1.gif" alt="An app titled 'LTER Animal Data Explorer'. The user starts on the 'About this App' page, which includes a couple paragraphs of intro text. The user then clicks on the 'Explore the Data' page which has two tabs: Trout and Penguins. On the Trout tab, we see a scatterplot with Trout Length (mm) on the x-axis and Trout Weight (g) on the y-axis. The user first filters data by Channel Type using a drop down list selector widget, then by Forest Section using two buttons that toggle on data from clear cut vs. old growth forest. In the Penguin tab, we see a histogram displaying Flipper Lengths (mm) of three penguin species. The user uses a drop down list selector widget to filter data by Island, then uses a slider widget to adjust the number of histogram bins." width="750"/></center>
:::

::::

. . . 

<p class="body-text-s">You'll notice that there are some UI quirks (most notably, blank plots that appear when no data is selected) that can make the user experience less than ideal (and even confusing) -- we'll learn about ways to improve this in v2 of our app.</p>

---

##  {#two-source data-menu-title="Two source panes"}

[Two files? Try two panes!]{.slide-title}

<hr>

<p class="body-text bottombr">We'll be building out a **two-file shiny app** this time around. You can open multiple scripts up side-by-side by navigating to **Tools** > **Global Options** > **Pane Layout** > **Add Column**</p>

<center><img src="images/two_source.png" alt="RStudio with three columns. (From left to right): (1) a source pane with `ui.R` open (2) a second source pane on the top with `server.R` open and the console on the bottom, (3) Environment/History/Git/etc. on the top and Files/Plots/Packages/etc. on the bottom" width="650"/></center>

<p class="body-text topbr">This setup is certainly not required/necessary -- organize your IDE however you work best!</p>

---

##  {#app2-plots data-menu-title="Draft Plots (app#2)"}

[Practice data wrangling, filtering & viz first!]{.slide-title3}

<hr>

<p class="body-text-s">Here's what I've done in my `~scratch/practice_script_app2_lter.R` file:</p>

::: {.panel-tabset}

## Trout plot

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
#..........................load packages.........................
library(lterdatasampler)
library(tidyverse)

#............custom ggplot theme (apply to both plots)...........
myCustomTheme <- theme_light() +
  theme(axis.text = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 13),
    legend.position = "bottom",
    panel.border = element_rect(linewidth = 0.7))

#.......................wrangle trout data.......................
clean_trout <- and_vertebrates |>
  filter(species == "Cutthroat trout") |>
  select(sampledate, section, species, length_mm = length_1_mm, weight_g, channel_type = unittype) |> 
  mutate(channel_type = case_when(
    channel_type == "C" ~ "cascade",
    channel_type == "I" ~ "riffle",
    channel_type =="IP" ~ "isolated pool",
    channel_type =="P" ~ "pool",
    channel_type =="R" ~ "rapid",
    channel_type =="S" ~ "step (small falls)",
    channel_type =="SC" ~ "side channel"
  )) |> 
  mutate(section = case_when(
    section == "CC" ~ "clear cut forest",
    section == "OG" ~ "old growth forest"
  )) |> 
  drop_na()

#..................practice filtering trout data.................
trout_filtered_df <- clean_trout |> 
  filter(channel_type %in% c("pool", "rapid")) |> 
  filter(section %in% c("clear cut forest"))

#........................plot trout data.........................
ggplot(trout_filtered_df, aes(x = length_mm, y = weight_g, color = channel_type, shape = channel_type)) +
  geom_point(alpha = 0.7, size = 5) +
  scale_color_manual(values = c("cascade" = "#2E2585", "riffle" = "#337538", "isolated pool" = "#DCCD7D", 
                                "pool" = "#5DA899", "rapid" = "#C16A77", "step (small falls)" = "#9F4A96", 
                                "side channel" = "#94CBEC")) +
  scale_shape_manual(values = c("cascade" = 15, "riffle" = 17, "isolated pool" = 19, 
                                "pool" = 18, "rapid" = 8, "step (small falls)" = 23, 
                                "side channel" = 25)) +
  labs(x = "Trout Length (mm)", y = "Trout Weight (g)", color = "Channel Type", shape = "Channel Type") +
  myCustomTheme
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/trout_plot.png" alt="A scatterplot with Trout Length (mm) on the x-axis and Trout Weight (g) on the y-axis. Data points are colored and shaped by Channel Type, with data collected from pools represented with green diamonds and data collected from rapids represented by red stars." width="550"/></center> 

<center><p class="body-text-s gray-text">We'll use the `and_vertebrates` data set from `{lterdatasampler}` to create a scatter plot of trout weights by lengths. When we move to shiny, we'll build 2 inputs for filtering our data: one to select `channel_type` and one to select `section`.</p></center>
:::

::::

## Penguin plot

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
#..........................load packages.........................
library(palmerpenguins)
library(tidyverse)

#..................practice filtering for island.................
island_df <- penguins %>%
  filter(island %in% c("Dream", "Torgesen"))

#........................plot penguin data.......................
ggplot(na.omit(island_df), aes(x = flipper_length_mm, fill = species)) +
  geom_histogram(alpha = 0.6, bins = 25) +
  scale_fill_manual(values = c("Adelie" = "#FEA346", "Chinstrap" = "#B251F1", "Gentoo" = "#4BA4A4")) +
  labs(x = "Flipper length (mm)", y = "Frequency",
       fill = "Penguin species") +
  myCustomTheme
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/penguin_plot.png" alt="A histogram of penguin Flipper lengths (mm) with bars colored by species. Adelie are orange and Chinstrap are purple." width="550"/></center> 
<center><p class="body-text-s gray-text">We'll use the `penguins` data set from `{palmerpenguins}` to create a histogram of penguin flipper lengths. When we move to shiny, we'll build 2 inputs for filtering our data: one to select `island` and one to change the number of histogram bins.</p></center>
:::

::::
:::

---

##  {#global.R data-menu-title="global.R"}

[A `global.R` file can help you keep code organized]{.slide-title2}

<hr>

<p class="body-text bottombr">While not a requirement of a shiny app, a `global.R` file will help reduce redundant code, increase your app's speed, and help keep code more clearly organized. It works by running once when your app is first launched, making any logic, objects, etc. contained in it available to both the `ui.R` and `server.R` files (or, in the case of a single-file shiny app, the `app.R` file). It's a great place for things like:</p>

. . . 

<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} loading packages</p>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} importing data</p>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} sourcing scripts (particularly functions -- we'll talk more about functions later)</p>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} data wrangling (though you'll want to do any major data cleaning before bringing your data into your app)</p>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} building custom `ggplot` themes</p>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} etc.</p>

<br>

. . . 

<p class="body-text topbr bottombr">**Reminder:** `global.R` *must* be saved to the same directory as your `ui.R` and `server.R` files.</p>

---

##  {#unstructured-app1 data-menu-title="Unstructured first app"}

[We created a perfectly functional first app, but it's not so visually pleasing]{.slide-title2}

<hr>

:::: {.columns}

::: {.column width="45%"}
<br>
<br>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} nothing really grabs your eye</p>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} inputs & outputs are stacked vertically on top of one another (which requires a lot of vertical scrolling)</p>
<p class="body-text-s">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} widget label text is difficult to distinguish from other text</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/app1.gif" alt="A gif of our first Shiny app. The title, 'My App Title' is in large black text at the top. Underneath, the subtitle, 'Exploring Antarctc Penguin Data' is in smaller black text. Immediately beneath, there is a sliderInput with black text above it that says, 'Select a range of body masses (g). The user is sliding both upper and lower ends to select a range of body masses to display data for. The scatterplot, with Flipper length (mm) on the x-axis and Bill length (mm) on the y-axis, updates accordingly. The user then scrolls down to a DT datatable. Immediately below the first plot is text that says 'Select year(s):' with checkboxes next to the years 2007, 2008, and 2009. The boxes next to 2007 and 2008 are already checked. The user also selects the box next to 2009. The user then uses a drop down menu to display 50 entries (rather than the default 10). The user clicks on the 'bill_length_mm' column to rearrange the data in descending order." width="550"/></center> 
:::

::::

<br>

<p class="body-text">Before we jump into adding reactive outputs to our next app, we'll first plan out the visual structure of our UI -- first on paper, then with layout functions.</p>

---

##  {#layout-functions data-menu-title="Layout functions"}

[Layout functions provide the high-level visual structure of your app]{.slide-title2}

<hr>

<p class="body-text-s">Layouts are created using a **hierarchy** of function calls (typically) *inside* `fluidPage()`. Layouts often require a series functions -- **container** functions establish the larger area within which other layout elements are placed. See a few minimal examples of layout functions on the following slides (though [more exist](https://shiny.rstudio.com/articles/layout-guide.html)!).</p>

<p class="body-text-s">**Some useful layout function pairings:**</p>
```{r}
#| eval: false
#| echo: true
# sidebar for inputs & main area for outputs within the sidebarLayout() container
sidebarLayout(
  sidebarPanel(),
  mainPanel()
)
# multi-row fluid layout (add any number of fluidRow()s to a fluidPage())
fluidRow(
  column(4, ...),
  column(8, ...)
)
# tabPanel()s to contain HTML components (e.g. inputs/outputs) within the tabsetPanel() container
tabsetPanel(
  tabPanel()
)
# NOTE: can use navbarPage() in place of fluidPage(); creates a page with top-level navigation bar that can be used to toggle tabPanel() elements
navbarPage(
  tabPanel()
)
```

---

##  {#layout-function-examples data-menu-title="Layout Examples"}

[Example UI layouts]{.slide-title}

<hr>

<p class="body-text-s">**Note:** You can combine multiple layout function groups to really customize your UI -- for example, you can create a navbar, include tabs, and also establish sidebar and main panel areas for inputs and outputs.</p>

::: {.panel-tabset}

## Sidebar & main area

<p class="body-text">To create a page with a **side bar and main area** to contain your inputs and outputs (respectively), explore the following layout functions and read up on the [sidebarLayout documentation](https://shiny.rstudio.com/reference/shiny/1.6.0/sidebarlayout):</p>

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
fluidPage(
  titlePanel(
    # app title/description
  ),
  sidebarLayout(
    sidebarPanel(
      # inputs here
    ),
    mainPanel(
      # outputs here
    )
  )
)
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/sidebar_layout.png" alt="A simplified schematic of a Shiny app with a sidebar layout. The page as a whole is created with the fluidPage() function. The titlePanel() function creates a row at the top of the page for a title. The sidebarLayout() function creates a new row below titlePanel(). Within the sidebarLayout(), there are two side-by-side columns created using the sidebarPanel() function (to the left) and the mainPanel() function (to the right)." width="650"/></center>
:::

::::

## Page with multiple rows

<p class="body-text">To create a **page with multiple rows**, explore the following layout functions and check out the [fluid layout](https://shiny.rstudio.com/reference/shiny/1.6.0/fluidpage) documentation. Note that each row is made up of **12** columns. The first argument of the `column()` function takes a value of 1-12 to specify the number of columns to occupy.</p>

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
fluidPage(
  fluidRow(
    column(4, 
      ...
    ),
    column(8, 
      ...
    )
  ),
  fluidRow(
    column(6, 
      ...
    ),
    column(6, 
      ...
    )
  )
)
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/multirow_layout.png" alt="A simplified schematic of a Shiny app with a multi-row layout. The page as a whole is created with the fluidPage() function. Within that, the fluidRow() function is used twice to create two stacked (one atop the other) rows on the page. Within each fluidRow are two side-by-side columns, each created using the column() function. Each row is made up of 12 columns. The column() function takes a value of 1-12 as the first arguement to specify how many of those 12 columns to occupy." width="650"/></center>
:::

::::

## Tabs

<p class="body-text">You may find that you eventually end up with too much content to fit on a single application page. Enter `tabsetPanel()` and `tabPanel()`. `tabsetPanel()` creates a container for any number of `tabPanel()`s. Each `tabPanel()` can contain any number of HTML components (e.g. inputs and outputs). Find the [tabsetPanel documentation here](https://shiny.rstudio.com/reference/shiny/1.5.0/tabsetpanel) and check out this example:</p>

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
tabsetPanel(
  tabPanel("Tab 1", 
    # an input
    # an output
  ),
  tabPanel("Tab 2"),
  tabPanel("Tab 3")
)
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/tabsetPanel_layout.png" alt="A simplified schematic of a Shiny app with a tabsetPanel layout. The page as a whole is created with the fluidPage() function. Within that, the tabsetPanel() function creates a container within which three tabPanel()s ('Tab 1', 'Tab 2', 'Tab 3') are defined (for this particular example). Tab 1 is highlighted and has placeholder text which says '# an input' and then on the line below, '# an output'." width="650"/></center>
:::

::::

## Navbar

<p class="body-text">You may also want to use a navigation bar (`navbarPage()`) with different pages (created using `tabPanel()`) to organize your application. Read through the [navbarPage documentation](https://shiny.rstudio.com/reference/shiny/1.6.0/navbarpage) and try running the example below:</p>

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
navbarPage(
  title = "My app",
  tabPanel(title = "Tab 1",
           # an input
           # an output
           ),
  tabPanel(title = "Tab 2")
)
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/navbarPage_layout.png" alt="A simplified schematic of a Shiny app with a navbarPage layout. The page as a whole is created with the navbarPage() function. A top-level navigation bar can be used to toggle between two tabPanel()s ('Tab 1', 'Tab 2'), which are defined for this particular example. Tab 1 is highlighted and has placeholder text which says '# an input' and then on the line below, '# an output'." width="650"/></center>
:::

::::

:::

<center><p class="body-text-s">Examples adapted from [Mastering Shiny, Ch. 6](https://mastering-shiny.org/action-layout.html#action-layout), by Hadley Wickham:</p></center>

---


##  {#layout-fxns-app2 data-menu-title="Overview of App #2 Layout"}

[Overview of layout functions used in App #2]{.slide-title2}

<hr>

<center><img src="images/app2-layout-fxns.png" alt="" width="900"/></center>

---

##  {#build-navbar data-menu-title="Build navbar"}

[Build a navbar with two pages]{.slide-title2}

<hr>

<p class="body-text-s">First, let's build a UI that has a navigation bar with two tabs -- one for background information and one to contain our data visualizations. To do this, we'll use `navbarPage()` instead of `fluidPage()` to create our webpage.</p>

<p class="body-text-s">**Tip:** It can be *super* helpful add code comments at the start and end of each UI element -- for example, see `# data viz tabPanel---` and `# END data viz tabPanel`, below. Adding text that you will eventually replace with content (e.g. plots, tables, images, longer text) may help to visualize what you're working towards as well.</p>
```{r}
#| eval: false
#| echo: true
ui <- navbarPage(
  
  title = "LTER Animal Data Explorer",
  
  # (Page 1) intro tabPanel ----
  tabPanel(title = "About this App",
           
           "background info will go here" # REPLACE THIS WITH CONTENT
           
  ), # END (Page 1) intro tabPanel
  
  # (Page 2) data viz tabPanel ----
  tabPanel(title =  "Explore the Data",
           
           "reactive plots will go here" # REPLACE THIS WITH CONTENT
           
  ) # END (Page 2) data viz tabsetPanel
  
) # END navbarPage
```

---

##  {#add-tabs data-menu-title="Add tabs"}

[Add two tabs to the "Explore the Data" page]{.slide-title2}

<hr>

<p class="body-text-s">Give your tabs the following titles: `Trout` and `Penguins`.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "15-34"
ui <- navbarPage(
  
  title = "LTER Animal Data Explorer",
  
  # (Page 1) intro tabPanel ----
  tabPanel(title = "LTER Animal Data Explorer",
           
           "background info will go here"  # REPLACE THIS WITH CONTENT
           
  ), # END (Page 1) intro tabPanel
  
  # (Page 2) data viz tabPanel ----
  tabPanel(title =  "Explore the Data",
           
           # tabsetPanel to contain tabs for data viz ----
           tabsetPanel(
             
             # trout tabPanel ----
             tabPanel(title = "Trout",
                      
                      "trout data viz here"  # REPLACE THIS WITH CONTENT
                      
             ), # END trout tabPanel 
             
             # penguin tabPanel ----
             tabPanel(title = "Penguins",
                      
                      "penguin data viz here"  # REPLACE THIS WITH CONTENT
                      
             ) # END penguin tabPanel
             
           ) # END tabsetPanel
           
  ) # END (Page 2) data viz tabPanel
  
) # END navbarPage
```

---

##  {#sidebar-main-panels data-menu-title="Create sidebar & main panels"}

[Add sidebar & main panels to the `Trout` tab]{.slide-title2}

<hr>

<p class="body-text-s">We'll eventually place our input in the sidebar and output in the main panel.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "21-38"
ui <- navbarPage(
  
  title = "LTER Animal Data Explorer",
  
  # (Page 1) intro tabPanel ----
  tabPanel(title = "About this App",
           
           "background info will go here"  # REPLACE THIS WITH CONTENT
           
  ), # END (Page 1) intro tabPanel
  
  # (Page 2) data viz tabPanel ----
  tabPanel(title = "Explore the Data",
           
           # tabsetPanel to contain tabs for data viz ----
           tabsetPanel(
             
             # trout tabPanel ----
             tabPanel(title = "Trout",
                      
                      # trout sidebarLayout ----
                      sidebarLayout(
                        
                        # trout sidebarPanel ----
                        sidebarPanel(
                          
                          "trout plot input(s) go here" # REPLACE THIS WITH CONTENT
                          
                        ), # END trout sidebarPanel
                        
                        # trout mainPanel ----
                        mainPanel(
                          
                          "trout plot output goes here" # REPLACE THIS WITH CONTENT
                          
                        ) # END trout mainPanel
                        
                      ) # END trout sidebarLayout
                      
             ), # END trout tabPanel 
             
             # penguin tabPanel ----
             tabPanel(title = "Penguins",
                      
                      "penguin data viz here"  # REPLACE THIS WITH CONTENT
                      
             ) # END penguin tabPanel
             
           ) # END tabsetPanel
           
  ) # END (Page 2) data viz tabPanel
  
) # END navbarPage
```

---

##  {#exercise2-prompt data-menu-title="** Exercise 2 Prompt **"}

[{{< fa question title="question mark" >}} Exercise 2: Add sidebar and main panels to the `Penguins` tab]{.slide-title2}

<hr>

:::: {.columns}

::: {.column width="45%"}
<br>
<br>
<p class="body-text">I encourage you to type the code out yourself, rather than copy/paste! And be sure to add text where your input/output will eventually be placed. When you're done, you app should look like this:</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/app2_layout.gif" alt="Our new app, which does not yet contain any content (e.g inputs and outputs), but does have an organized layout structure. There is a navbar across the top of the page, with the title 'My app title' on the left-hand side of the navbar. There are two pages on the navbar: one says 'Welcome to my app' and the second says 'Explore the data'. The user clicks into the second page to reveal two tabs named 'Trout', and 'Bison'. Each tab has a gray box (a sidebar) on the lefthand side and a main panel space to the right." width="550"/></center>
:::

::::

<br>

<center><p class="body-text-xl teal-text">See next slide for a solution!</p></center>

---

##  {#exercise2-solution data-menu-title="** Exercise 2 Solution **"}

[{{< fa check title="a check mark" >}} Exercise 2: A solution]{.slide-title2}

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "45-62"
ui <- navbarPage(
  
  title = "LTER Animal Data Explorer",
  
  # (Page 1) intro tabPanel ----
  tabPanel(title = "About this App",
           
           "background info will go here" # REPLACE THIS WITH CONTENT
           
  ), # END (Page 1) intro tabPanel
  
  # (Page 2) data viz tabPanel ----
  tabPanel(title = "Animal Data Explorer",
           
           # tabsetPanel to contain tabs for data viz ----
           tabsetPanel(
             
             # trout tabPanel ----
             tabPanel(title = "Trout",
                      
                      # trout sidebarLayout ----
                      sidebarLayout(
                        
                        # trout sidebarPanel ----
                        sidebarPanel(
                          
                          "trout plot input(s) go here" # REPLACE THIS WITH CONTENT
                          
                        ), # END trout sidebarPanel
                        
                        # trout mainPanel ----
                        mainPanel(
                          
                          "trout plot output goes here" # REPLACE THIS WITH CONTENT
                          
                        ) # END trout mainPanel
                        
                      ) # END trout sidebarLayout
                      
             ), # END trout tabPanel 
             
             # penguin tabPanel ----
             tabPanel(title = "Penguins",
                      
                      # penguin sidebarLayout ----
                      sidebarLayout(
                        
                        # penguin sidebarPanel ----
                        sidebarPanel(
                          
                          "penguin plot input(s) go here" # REPLACE THIS WITH CONTENT
                          
                        ), # END penguin sidebarPanel
                        
                        # penguin mainPanel ----
                        mainPanel(
                          
                          "penguin plot output goes here" # REPLACE THIS WITH CONTENT
                          
                        ) # END penguin mainPanel
                        
                      ) # END penguin sidebarLayout
                      
             ) # END penguin tabPanel
             
           ) # END tabsetPanel
           
  ) # END (Page 2) data viz tabPanel
  
) # END navbarPage
```

---

##  {#layout-review data-menu-title="Layout review"}

[Some important things to remember when building your UI's layout:]{.slide-title}

<hr>

. . . 

<p class="body-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} try creating a **rough sketch** of your intended layout *before* hitting the keyboard (I like to think of this as UI layout "pseudocode")</p>

. . . 

<p class="body-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} keeping **clean code is important** -- we haven't even any added any content yet and our UI is already >70 lines of code!</p>

. . . 

<p class="body-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} use **rainbow parentheses**, **code comments** and plenty of **space between lines** to keep things looking manageable and navigable</p>

. . . 

<p class="body-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} use the keyboard shortcut, `command` + `I` (Mac) or `control` + `I` (Windows), to align messy code -- this helps put those off-alignment parentheses back where they belong</p>

. . . 

<p class="body-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} things can get out of hand quickly -- **add one layout section at a time**, run your app to check that things look as you intend, then continue</p>

---

##  {#first-trout data-menu-title="First up, trout"}

[Add data viz: First up, trout]{.slide-title}

<hr>

<p class="body-text-s bottombr">We'll be using the [`and_vertebrates` dataset](https://lter.github.io/lterdatasampler/reference/and_vertebrates.html) from the [`{lterdatasampler}` package](https://lter.github.io/lterdatasampler/) to create our first reactive plot. These data contain coastal cutthroat trout (*Oncorhynchus clarkii clarkii*) lengths and weights collected in Mack Creek, [Andrews Forest LTER](https://andrewsforest.oregonstate.edu/). Original data can be found on the [EDI Data Portal](https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-and.4027.14). Refer back to [this slide](https://ucsb-meds.github.io/EDS430-Shiny/#/app2-plots) to revisit our practice data wrangling & visualization script.</p>

<br>

<center><img src="images/trout.png" alt="A drawing of the right-side profile of a coastal cutthroat trout." width="600"/></center>

<center><p class="body-text-s gray-text">Image Source: Joseph R. Tomelleri, as found on the [Western Native Trout Initiative](https://westernnativetrout.org/coastal-cutthroat-trout/)</p>

---

##  {#import-packages-global data-menu-title="Import packages in global.R"}

[Add packages & wrangle data in `global.R`]{.slide-title3}

<hr>

<p class="body-text-s">In addition to the [`{lterdatasampler}` package](https://lter.github.io/lterdatasampler/), we'll also be using the `{tidyverse}` for data wrangling/visualization, and the [`{shinyWidgets}` package ](https://github.com/dreamRs/shinyWidgets) to add a `pickerInput` and a `checkboxGroupInput` to our app.</p>  

<p class="body-text-s">**Import those three packages at the top of your `global.R` file**</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "3-5"
# LOAD LIBRARIES ----
library(shiny)
library(lterdatasampler) 
library(tidyverse)
library(shinyWidgets) 
```

---

##  {#wrangle-data-global data-menu-title="Wrangle data in global.R"}

[Add packages & wrangle data in `global.R`]{.slide-title3}

<hr>

<p class="body-text-s">We can also do the bulk of our data wrangling here, rather than in the server (to keep our server code a bit more manageable). If we were reading in a data file (e.g. .csv), we would do that here too. Our new data object `clean_trout`, will now be available for us to call directly in our server.</p>

<p class="body-text-s">We can easily copy our wrangling code over from our [practice script](https://ucsb-meds.github.io/EDS430-Shiny/#/app2-plots).</p>
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "6-24"
# LOAD LIBRARIES ----
library(shiny)
library(lterdatasampler)
library(tidyverse)
library(shinyWidgets) 

# DATA WRANGLING ----
clean_trout <- and_vertebrates |>
  filter(species == "Cutthroat trout") |>
  select(sampledate, section, species, length_mm = length_1_mm, weight_g, channel_type = unittype) |> 
  mutate(channel_type = case_when(
    channel_type == "C" ~ "cascade",
    channel_type == "I" ~ "riffle",
    channel_type =="IP" ~ "isolated pool",
    channel_type =="P" ~ "pool",
    channel_type =="R" ~ "rapid",
    channel_type =="S" ~ "step (small falls)",
    channel_type =="SC" ~ "side channel"
  )) |> 
  mutate(section = case_when(
    section == "CC" ~ "clear cut forest",
    section == "OG" ~ "old growth forest"
  )) |> 
  drop_na()
```

---

##  {#trout-pickerInput data-menu-title="Add Trout pickerInput()"}

[Add a `pickerInput` for selecting `channel_type` to your UI]{.slide-title2}

<hr>

<p class="body-text-s">The `channel_type` variable (originally called `unittype` -- we updated the name when wrangling data (see line 9 on [previous slide](https://ucsb-meds.github.io/EDS430-Shiny/#/wrangle-data-global))) represents the type of water body (*cascade, riffle, isolated pool, pool, rapid, step (small falls), or side channel*) data were collected in. We'll start by building a `shinyWidgets::pickerInput()` to allow users to filter data based on `channel_type`.</p>

. . . 

<p class="body-text-s topbr">**Reminder:** When we we designed our UI layout, we added a `sidebarPanel` to our **Trout** tab with the placeholder text `"trout plot input(s) go here"`. Replace that text with the code for your `pickerInput`:</p>

```{r}
#| eval: false
#| echo: true
# channel type pickerInput ----
pickerInput(inputId = "channel_type_input", label = "Select channel type(s):",
            choices = unique(clean_trout$channel_type), # alternatively: choices = c("rapid", "cascade" ...)
            options = pickerOptions(actionsBox = TRUE), # creates "Select All / Deselect All" buttons
            selected = c("cascade", "pool"), 
            multiple = TRUE) # END channel type pickerInput
```

<p class="body-text-s topbr">Save and run your app -- a functional `pickerInput` should now appear in your UI.</p>

<br>

<p class="body-text-s gray-text topbr">A `shinyWidgets::pickerInput()` is functionally equivalent to `shiny::selectInput()`, though it allows for greater customization and looks (in my opinion) a bit nicer.</p>

---

##  {#trout-output data-menu-title="Add Trout output"}

[Add a plot output to your UI]{.slide-title}

<hr>

<p class="body-text-s">Next, we need to create a placeholder in our UI for our trout scatterplot to live. Because we'll be creating a reactive plot, we can use the `plotOutput()` function to do so.</p>

. . . 

<p class="body-text-s topbr">**Reminder:** When we we designed our UI layout, we added a `mainPanel` to our **Trout** tab with the placeholder text `"trout plot output goes here"`. Replace that text with the code for your `plotOuput()`:</p>

```{r}
#| eval: false
#| echo: true
plotOutput(outputId = "trout_scatterplot")
```

<p class="body-text-s topbr">Save and run your app -- it won't look different at first glance, but inspecting your app in a browser window (using Chrome, right click > Inspect) will reveal a placeholder box for your plot output to eventually live:</p>

<center><img src="images/trout_plotOutput.png" alt="The Trout tab of our app, which contains only a pickerInput with the variables, cascade and pool, selected. There is no visible plot yet, however using Google Chrome's developer tools shows a div (i.e. a box) placeholder where our plot will eventually appear." width="600"/></center>

---

##  {#trout-plot data-menu-title="Trout Reactive Plot"}

[Tell the server how to assemble `pickerInput` values into your `plotOutput`]{.slide-title3}

<hr>

<p class="body-text-s">**Remember the three rules for building reactive outputs:** **(1)** save objects you want to display to `output$<id>`, **(2)** build reactive objects using a `render*()` function, and **(3)** access input values with `input$<id>`. When complete, your server should contain the following code:</p>

:::: {.columns}

::: {.column width="55%"}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "3-25"
server <- function(input, output) {
  
  # filter trout data ----
  trout_filtered_df <- reactive({
    
    clean_trout |>
      filter(channel_type %in% c(input$channel_type_input))
    
  })
  
  # trout scatterplot ----
  output$trout_scatterplot <- renderPlot({
    
    ggplot(trout_filtered_df(), aes(x = length_mm, y = weight_g, color = channel_type, shape = channel_type)) +
      geom_point(alpha = 0.7, size = 5) +
      scale_color_manual(values = c("cascade" = "#2E2585", "riffle" = "#337538", "isolated pool" = "#DCCD7D",
                                    "pool" = "#5DA899", "rapid" = "#C16A77", "step (small falls)" = "#9F4A96",
                                    "side channel" = "#94CBEC")) +
      scale_shape_manual(values = c("cascade" = 15, "riffle" = 17, "isolated pool" = 19,
                                    "pool" = 18, "rapid" = 8, "step (small falls)" = 23,
                                    "side channel" = 25)) +
      labs(x = "Trout Length (mm)", y = "Trout Weight (g)", color = "Channel Type", shape = "Channel Type") +
      myCustomTheme
    
  }) 
  
} # END server
```
:::

::: {.column width="5%"}
:::

::: {.column width="35%"}
<p class="body-text">**A couple notes/reminders:**</p>

<p class="body-text-s topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text}  If needed, reference your [practice script](https://ucsb-meds.github.io/EDS430-Shiny/#/app2-plots) to remind yourself how you planned to filter and plot your data</p>

<p class="body-text-s topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text}  Reactive data frames need a set of parentheses, `()`, following the name of the df (see `ggplot(trout_filtered_df() ...)`)</p>

<p class="body-text-s topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} For a cohesive appearance, save your ggplot theme parameters to a named object in `global.R` (here, `myCustomTheme`), then apply to all plots in your app. See the [following slide](https://ucsb-meds.github.io/EDS430-Shiny/#/ggplot-theme) for code.</p>
:::

::::

---

##  {#ggplot-theme data-menu-title="Save theme to global.R"}

[Save a custom `ggplot` theme to `global.R`]{.slide-title2}

<hr>

<p class="body-text-s">Rather than re-typing your ggplot theme parameters out for every plot in your app, do so once in `global.R`, and save to an object name. You can then easily add your custom theme as a layer to each of your ggplots. **Bonus:** If you decide to modify your plot theme, you only have to do so in one place!</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "27-34"
# LOAD LIBRARIES ----
library(shiny)
library(lterdatasampler)
library(palmerpenguins)
library(tidyverse)
library(shinyWidgets)

# DATA WRANGLING ----
clean_trout <- and_vertebrates |>
  filter(species == c("Cutthroat trout")) |>
  select(sampledate, section, species, length_mm = length_1_mm, weight_g, channel_type = unittype) |> 
  mutate(channel_type = case_when(
    channel_type == "C" ~ "cascade",
    channel_type == "I" ~ "riffle",
    channel_type =="IP" ~ "isolated pool",
    channel_type =="P" ~ "pool",
    channel_type =="R" ~ "rapid",
    channel_type =="S" ~ "step (small falls)",
    channel_type =="SC" ~ "side channel"
  )) |> 
  mutate(section = case_when(
    section == "CC" ~ "clear cut forest",
    section == "OG" ~ "old growth forest"
  )) |> 
  drop_na()

# GGPLOT THEME ----
myCustomTheme <- theme_light() +
  theme(axis.text = element_text(color = "black", size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 13),
    legend.position = "bottom",
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.7))
```

---

##  {#run-app2v1-first-widget  data-menu-title="Run the App (trout pickerInput)"}

[Run your app and try out your `pickerInput` widget!]{.slide-title}

<hr>

<center><img src="images/app2_plot1_widget1.gif" alt="A user navigates to the 'Explore the Data' tab of our app, 'LTER Animal Data Explorer.' There is a scatterplot with Trout Length (mm) on the x-axis, and Trout Weight (g) on the y-axis. Points are colored and shaped by channel type. There is a pickerWidget to the left of the plot with the channel_types 'cascade' and 'pool' already selected. The user clicks other channel types on/off to see how the data points on the plot change." width="750"/></center>

---

##  {#second-input-ui data-menu-title="Add a second input"}

[Add a second input that will update the same output]{.slide-title}

<hr>

<p class="body-text-s">You can have more than one input control the same output. Let's now add a `checkboxGroupButtons` widget to our **UI** for selecting forest `section` (either clear cut forest or old growth forest). Check out the [function documentation](https://dreamrs.github.io/shinyWidgets/reference/checkboxGroupButtons.html) for more information on how to customize the appearance of your buttons.</p>

<p class="body-text-s">Be sure to add the widget to the same `sidebarPanel` as our `pickerInput` (and separate them with a comma, `,`!:</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "11-16"
# trout plot sidebarPanel ----
sidebarPanel(
  
  # channel type pickerInput ----
  pickerInput(inputId = "channel_type_input", label = "Select channel type(s):",
              choices = unique(clean_trout$channel_type),
              options = pickerOptions(actionsBox = TRUE),
              selected = c("cascade", "pool"),
              multiple = TRUE), # END channel type pickerInput

  # section checkboxGroupButtons ----
  checkboxGroupButtons(inputId = "section_input", label = "Select a sampling section(s):",
                       choices = c("clear cut forest", "old growth forest"),
                       selected = c("clear cut forest", "old growth forest"),
                       individual = FALSE, justified = TRUE, size = "sm",
                       checkIcon = list(yes = icon("ok", lib = "glyphicon"), no = icon("remove", lib = "glyphicon"))), # END section checkboxGroupInput
                   
            ) # END trout plot sidebarPanel
```

---

##  {#second-input-server data-menu-title="Update reactive trout df"}

[Update your reactive df to *also* filter based on the new `checkboxGroupInput`]{.slide-title2}

<hr>

<p class="body-text-s">Return to your **server** to modify `trout_filtered_df` -- our data frame needs to be updated based on both the `pickerInput`, which selects for `channel_type`, *and* the `checkboxGrouptInput`, which selects for forest `section`:</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "6"
# filter trout data ----
trout_filtered_df <- reactive({

    clean_trout |>
      filter(channel_type %in% c(input$channel_type_input)) |>
      filter(section %in% c(input$section_input))
      
  })

# trout scatterplot ----
output$trout_scatterplot <- renderPlot({

  ggplot(trout_filtered_df(), aes(x = length_mm, y = weight_g, color = channel_type, shape = channel_type)) +
    geom_point(alpha = 0.7, size = 5) +
    scale_color_manual(values = c("cascade" = "#2E2585", "riffle" = "#337538", "isolated pool" = "#DCCD7D",
                                  "pool" = "#5DA899", "rapid" = "#C16A77", "step (small falls)" = "#9F4A96",
                                  "side channel" = "#94CBEC")) +
    scale_shape_manual(values = c("cascade" = 15, "riffle" = 17, "isolated pool" = 19,
                                  "pool" = 18, "rapid" = 8, "step (small falls)" = 23,
                                  "side channel" = 25)) +
    labs(x = "Trout Length (mm)", y = "Trout Weight (g)", color = "Channel Type", shape = "Channel Type") +
    myCustomTheme

 })
```

---

##  {#run-app2v1-second-widget data-menu-title="Run the App"}

[Run your app and try out your `pickerInput` & `checkboxGrouptInput` widgets!]{.slide-title2}

<hr>

<center><img src="images/app2_plot1_widget2.gif" alt="Our updated app, which includes the same trout scatterplot, but this time, two inputs: one selectInput that allows the user to filter for channel_type, and one checkboxGroupInput, which includes two buttons to select/deselect data collected from the clear cut forest section and the old growth forest section." width="750"/></center>



