---
format: revealjs
editor_options: 
  chunk_output_type: console
---

##  {#build-app1 data-menu-title="~~~ Building App #1 ~~~" background="#053660"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">{{< fa tools title="a wrench and screwdriver" >}} Building out your 1<sup>st</sup> app</p>
<p class="caption-text">*Here, we'll create our first reactive objects and establish a general Shiny coding workflow.*</p>
</div>

---

##  {#LO-app1 data-menu-title="Learning Objectives - App #1"}

[{{< fa book-open title="an open book" >}} Learning Objectives - App #1 (single-file app)]{.slide-title-smaller}

<hr>

<p class="medium-body-text bottombr">By the end of building out this first app, you should be a bit more familiar with:</p>

. .  .

<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} writing a single-file (`app.R`) shiny app</p>

. . . 

<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} adding and styling text in the UI using `tags`</p>

. . . 

<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} practicing data wrangling and visualization *outside* of your shiny app</p>

. . . 

<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} following a general workflow for building reactive apps, which includes adding **inputs** and **outputs** to the **UI**, then writing the **server instructions** on how to assemble user input values into outputs</p>

. .  .

<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} running and quitting apps in RStudio</p>

. . . 

<p class="medium-body-text topbr">Packages introduced:</p> 

. . . 

<p class="small-text">[{{< fa box-open title="an open box" >}}]{.teal-text} `{shiny}`: framework for building our reactive app + standard widgets</p>

. . . 

<p class="small-text">[{{< fa box-open title="an open box" >}}]{.teal-text} `{DT}`: interactive datatable widgets (that can be made reactive using shiny!)</p>

. . . 

<p class="small-text">[{{< fa box-open title="an open box" >}}]{.teal-text} `{tidyverse}`: collection of packages for wrangling & visualizing data</p>   

. . . 

<p class="small-text">[{{< fa box-open title="an open box" >}}]{.teal-text} `{palmerpenguins}`: data</p>

---

##  {#roadmap-app1 data-menu-title="Roadmap App#1"}

[Roadmap for App #1]{.slide-title}

<hr>

<p class="body-text">We'll start by building a small **single-file app** using data from the `{palmerpenguins}` package. We'll build out the the following features:</p>

:::: {.columns}

::: {.column width="45%"}
<br>
<br>

<p class="body-text">**(a)** A title and subtitle</p>

<p class="body-text topbr">**(b)** A slider widget for users to select a range of penguin body masses</p>

<p class="body-text topbr">**(c)** A reactive scatterplot that updates based on user-supplied values</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/reactive_app_v1.gif" alt="A gif of our current Shiny app, demonstrating reactivity. At the top left of our app is the title, 'My App Title' in large header font. Beneath it is a subtitle, 'Exploring Antarctic Penguins and Temperatures'. Below the subtitle is the slider input with the label, 'Select a range of body masses (g)'. A gray horizontal slider bar ranges from the values 2,700 to 6,300. The interactive slider value selectors are two round white circles, which, when moved apart from one another highlight the selected value range in blue. The user is adjusting the slider value selectors and the scatterplot of penguin bill length (mm) vs. flipper length (mm) is automatically updating." width="700"/></center>
:::

::::

---

##  {#adding-text data-menu-title="Adding text"}

[Add text in the UI]{.slide-title-smaller}

<hr>

<p class="small-text">We'll do this in the **UI** within `fluidPage()`, a layout function that sets up the basic visual structure of the page and scales components in real time to fill all available browser width. Add a title and subtitle to your app (be sure to separate each with a comma, `,`), save, and run:</p>

```{r}
#| eval: false
#| echo: true
# user interface ----
ui <- fluidPage(
  
  # app title ----
  "My App Title",
  
  # app subtitle ----
  "Exploring Antarctic Penguin Data"
  
  )
```

. . . 

<p class="small-text">Recall that the UI is actually just an HTML document. We can style our text by adding static HTML elements [using `tags`](https://shiny.rstudio.com/articles/tag-glossary.html) -- a list of functions that parallel common HTML tags (e.g. `<h1>` == `tags$h1()`) The most common tags also have wrapper functions (e.g. `h1()`).</p>

```{r}
#| eval: false
#| echo: true
# user interface ----
ui <- fluidPage(
  
  # app title ----
  tags$h1("My App Title"), # alternatively, you can use the `h1()` wrapper function
  
  # app subtitle ----
  p(strong("Exploring Antarctic Penguin Data")) # alternatively, `tags$p(tags$strong("text"))`
  
  )
```

---

##  {#inputs-outputs data-menu-title="Inputs & Outputs"}

[What are inputs and outputs?]{.slide-title}

<hr>

<p class="small-text">Next, we will begin to add some inputs and outputs to our UI inside `fluidPage()` (anything that you put into `fluidPage()` will appear in our app's user interface...and we want inputs and outputs to show up there!).</p>

<p class="small-text">**Inputs** (or widgets) are the things that users can interact with (e.g. toggle, slide) and provide values to your app. The input functions below correspond to the widgets you see on [slide #9](https://ucsb-meds.github.io/EDS430-Shiny/#/widgets). **Outputs** are the R objects that your user sees (e.g. tables, plots) and are what respond when a user interacts with/changes an input value.</p>

<p class="small-text">The `shiny` package comes with a number of input and output functions, but you can extend these with additional packages (e.g. `shinyWidgets`, `plotly`, `DT`, etc.; more on those later).</p>

:::: {.columns}

::: {.column width="45%"}
<p class="body-text">**Examples of Input Functions:**</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `actionButton()`</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `checkboxInput()`</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `checkboxGroupInput()`</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `dateInput()`</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `dateRangeInput()`</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `radioButtons()`</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `selectInput()`</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `sliderInput()`</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `textInput()`</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} See full list of `shiny` input functions [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson3/)</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<p class="body-text">**Examples of Output Functions:**</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `dataTableOutput()` (inserts an interactive table)</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `imageOutput()` (inserts an image)</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `plotOutput()` (inserts a plot)</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `tableOutput()` (inserts a table)</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} `textOutput()` (inserts text)</p>  
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} See full list of `shiny` output functions [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson4/)</p>  
:::

::::

---

##  {#reactive-plot-app1 data-menu-title="Adding reactive plot (app #1)"}

[Adding our reactive plot]{.slide-title}

<hr>

<p class="small-text">Next, we'll create a **scatterplot of penguin bill lengths vs. penguin flipper lengths** using the `penguins` data set from the `{palmerpengiuns}` package. We will make this scatterplot *reactive* by adding a `sliderInput` that allows users to filter the displayed data points by **selecting a range of penguin body masses** (e.g. only plot bill and flipper lengths for penguins with body masses ranging from 4,500 grams to 6,000 grams).</p>

:::: {.columns}

::: {.column width="45%"}
<br>
<p class="small-text">**To create a reactive plot, we will follow these steps:**</p>
<p class="small-text topbr">**1.** Add an input (e.g. `sliderInput`) to the **UI** that users can interact with</p>
<p class="small-text">**2.** Add an output (e.g. `plotOutput`) to the **UI** that creates a *placeholder space* to fill with our eventual reactive output</p>
<p class="small-text">**3.** Tell the **server** how to assemble inputs into outputs</p>
:::

::: {.column width="5%"}
::: 

::: {.column width="45%"}
<center><img src="images/reactive_app_v1.gif" alt="A gif of our current Shiny app, demonstrating reactivity. At the top left of our app is the title, 'My App Title' in large header font. Beneath it is a subtitle, 'Exploring Antarctic Penguins and Temperatures'. Below the subtitle is the slider input with the label, 'Select a range of body masses (g)'. A gray horizontal slider bar ranges from the values 2,700 to 6,300. The interactive slider value selectors are two round white circles, which, when moved apart from one another highlight the selected value range in blue. The user is adjusting the slider value selectors and the scatterplot of penguin bill length (mm) vs. flipper length (mm) is automatically updating." width="700"/></center>
:::

::::

---

##  {#input-syntax data-menu-title="Input Syntax"}

[Input function syntax]{.slide-title}

<hr>

<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} **All input functions have the same first argument, `inputId`** (**NOTE:** `Id` *not* `ID`), **which is used to connect the front end of your app (the UI) with the back end (the server).** For example, if your UI has an `inputId = "name"`, the server function will access that input value using the syntax `input$name`. The `inputId` has two constraints: **(1)** it must be a simple string containing only letters, numbers, and underscores, **(2)** it must be unique within your app.</p>

<p class="small-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} Most input functions have a second parameter called `label`, which is used to create a human-readable label for the control, which will appear in the UI.</p>

<p class="small-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} The remaining arguments are unique to each input function. Oftentimes, these include a `value` parameter, which lets you set the default value of your widget, where applicable.</p>

<p class="body-text topbr">**A couple examples:**</p>
```{r}
#| eval: false
#| echo: true
sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):", value = c(3000, 4000), ...)

selectInput(inputId = "island_input", label = "Choose and island:", ...)
```

<p class="small-text topbr">Check out the interactive [Shiny Widgets Gallery](https://shiny.rstudio.com/gallery/widget-gallery.html) to learn how to implement the most common widgets.</p>

---

##  {#add-input data-menu-title="Add an Input"}

[**Step 1:** Add an input to your app]{.slide-title-smaller}

<hr>

<p class="body-text">First let's add a `sliderInput()` that will allow users to select a range of penguin body masses (g).</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "6-8"
# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider input ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000))
  )
```

. . . 

<p class="body-text">When you run your app, you should see something similar to the image below. It's operable, but does not yet have an associated output.</p>

<center><img src="images/3000_4000.png" alt="A basic Shiny app, with a title that says 'My App Title', a subtitle that says, 'Exploring Palmer Penguins and Antarctic Temperatures, and a slider input with a label that says 'Select a range of body masses (g)'. The slider bar has a minimum value of 2,700 and a maximum value of 6,300, and the moveable slider selectors currently range from 3,000 to 4,000." width="450"/></center>

---

##  {#output-syntax data-menu-title="Output Syntax"}

[Output function syntax]{.slide-title}

<hr>

<p class="body-text">Outputs in the UI create **placeholders** which are later filled by the server function.</p>

<p class="body-text topbr"> Similar to input functions, **all output functions take the same first argument, `outputId`** (again, note `Id` not `ID`), **which connects the front end UI with the back end server.** For example, if your UI contains an output function with an `outputId = "plot"`, the server function will access it (or in other words, know to place the plot in that particular placeholder) using the syntax `output$plot`.</p>

</p>

<p class="body-text topbr">**A couple examples:**</p>
```{r}
#| eval: false
#| echo: true
plotOutput(outputId = "bodyMass_scatterPlot")

dataTableOutput(outputId = "penguin_data")
```

---

##  {#add-output data-menu-title="Add Output"}

[**Step 2:** Add an output to your app]{.slide-title-smaller}

<hr>

<p class="small-text">Let's now add a `plotOutput()`, which will be updated based on the user inputs via the `sliderInput()`, then run the app.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "10-11"

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider input ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot ouput ----
  plotOutput(outputId = "bodyMass_scatterPlot")
  
  )
```

. . . 

:::: {.columns}

:::{.column width="45%"}
<br>
<p class="small-text">Okay, it looks like nothing changed?? **Remember, `*Output()` functions create placeholders, but we have not yet written the server instructions on how to fill and update those placeholders.** We can inspect the HTML and see that there is, in fact, a placeholder area awaiting our eventual output, which will be a plot named "*bodyMass_scatterPlot*":</p>
:::

:::{.column width="5%"}
:::

:::{.column width="45%"}
<center><img src="images/output_placeholder.png" alt="A Google Chrome browser window with our Shiny app open on the left-hand side and the underlying HTML document open on the right. The app looks the same as before, except hovering over the HTML associated with our new plotOutput highlights a blue square region beneath the sliderInput. This highlighted region is the placeholder where our plot will eventually be rendered." width="450"/></center>
:::

::::

---

##  {#rendering-outputs data-menu-title="Rendering outputs"}

[Rendering outputs]{.slide-title}

<hr>

<p class="body-text">Each `*Output()` function in the UI is coupled with a `render*()` function in the server, which contains the "instructions" for creating the output based on user inputs (or in other words, the instructions for making your output *reactive*).</p>

<br>

<center><p class="body-text topbr">**Examples of `*Output()` functions and their corresponding `render*()` functions:**</p></center>

| Output function     | Render function      |
|---------------------|----------------------|
| `dataTableOutput()` | `renderDataTable()`  |  
| `imageOutput()`     | `renderImage()`      |   
| `plotOutput()`      | `renderPlot()`       |  
| `tableOutput()`     | `renderTable()`      |  
| `textOutput()`      | `renderText()`       |  

---

##  {#assemble data-menu-title="Assemble Inputs into Outputs"}

[**Step 3:** Tell the server how to assemble inputs into outputs]{.slide-title}

<hr>

<p class="small-text">Now that we've designed our input/output in the UI, we need to write the server instructions (i.e. write the server function) on how to use the input value(s) (i.e. penguin body mass range via a slider input) to update the output (scatter plot).</p>

<p class="small-text">The **server function** is defined with two arguments, `input` and `output`, both of which are list-like objects. You *must* define both of these arguments within the server function. `input` contains the values of all the different inputs at any given time, while `output` is where you'll save output objects to display in the app.</p>

<p class="small-text">***This part can be intimidating, but if you follow these three rules, you will successfully create reactivity within your shiny app!***</p>

<p class="large-body-text">**Rules:**</p>

. . . 

<p class="body-text">**1.** Save objects you want to display to `output$<id>`</p>

<p class="body-text">**2.** Build reactive objects using a `render*()` function</p>

<p class="body-text">**3.** Access input values with `input$<id>`</p>

---

##  {#rule1 data-menu-title="Rule #1"}

[**Rule 1:** Save objects you want to display to `output$<id>`]{.slide-title-smaller}

<hr>

:::: {.columns}

::: {.column width="65%"}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "21-22"

# load packages ----
library(shiny)

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot") 
  
)

# server instructions ----
server <- function(input, output) {
  
  # render the scatter plot ----
  output$bodyMass_scatterPlot <- # code to generate plot here
  
}
```
:::

::: {.column width="5%"}
:::

::: {.column width="30%"}
<br>
<p class="small-text bottombr">In our **UI**, we created a placeholder for our plot using the `plotOutput()` function and gave it the Id `"bodyMass_scatterplot"`. In our server, we will save our plot to the output argument by its `outputId`.</p>

<p class="small-text important-text-bg topbr">**Note:** In the **UI**, our `outputId` is quoted (`"bodyMass_scatterPlot"`), but not in the **server** (`bodyMass_scatterPlot`).</p>
:::

::::

---

##  {#rule2.1 data-menu-title="Rule #2a"}

[**Rule 2:** Build reactive objects with `render*()`]{.slide-title-smallest}

<hr>

<p class="small-text">Use the appropriate `render*()` function to make your output reactive (e.g. if you have a     `plotOutput` in your UI, you will need to use `renderPlot()` in your server).</p>

<p class="small-text">Within your `render*()`, write any code inside a set of curly braces, `{}`. This allows you to include as many lines of code as it takes to build your object.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "22-26"

# load packages ----
library(shiny)

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot") 
  
)

# server instructions ----
server <- function(input, output) {
  
  # render the scatter plot ----
  output$bodyMass_scatterPlot <- renderPlot({
    
     # code to generate plot here
    
  }) 
}
```

---

##  {#rule2.2 data-menu-title="Practice in seperate script"}

[**An Aside:** Draft objects (e.g. plots) in a separate script first]{.slide-title-smaller}

<hr>

<p class="body-text bottombr">I find it easier to experiment and draft my objects (e.g. plots) first in a separate script, then copy the code over to the server after. I want to make a plot that looks like this:</p>

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true

# load packages
library(palmerpenguins)
library(tidyverse)

# create plot
ggplot(na.omit(penguins), 
       aes(x = flipper_length_mm, y = bill_length_mm, 
           color = species, shape = species)) +
  geom_point() +
  scale_color_manual(values = c("Adelie" = "#FEA346", "Chinstrap" = "#B251F1", "Gentoo" = "#4BA4A4")) +
  scale_shape_manual(values = c("Adelie" = 19, "Chinstrap" = 17, "Gentoo" = 15)) +
  labs(x = "Flipper length (mm)", y = "Bill length (mm)", 
       color = "Penguin species", shape = "Penguin species") +
  theme_minimal() +
  theme(legend.position = c(0.85, 0.2),
        legend.background = element_rect(color = "white"))
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/penguin_scatterplot.png" alt="A scatterplot with Flipper length (mm) on the x-axis and Bill length (mm) on the y-axis. Data points are colored by penguins species: Adelie in orange circles, Chinstrap in purple triangles, and Gentoo in green squares." width="450"/></center>
:::

::::

<p class="small-text important-text-bg">**Tip:** Save your practice script in a separate directory (i.e. not inside your app directory) -- I typically save mine to something like `~/scratch/practice_script.R`.</p>

---

##  {#rule2.3 data-menu-title="Copy code into server"}

[Copy your plot code into the server]{.slide-title-smaller}

<hr>

<p class="body-text">Copy your code over to your app, placing it inside the `{}` (and make sure to add any additional required packages to the top of your `app.R` script). Run your app. What do you notice?</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "25-35" 

# load packages ----
library(shiny)
library(palmerpenguins)
library(tidyverse)

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot")
  
)

# server instructions ----
server <- function(input, output) {
  
  # render the scatter plot ----
  output$bodyMass_scatterPlot <- renderPlot({ 
      ggplot(na.omit(penguins),
             aes(x = flipper_length_mm, y = bill_length_mm,
                 color = species, shape = species)) + 
        geom_point() + 
        scale_color_manual(values = c("Adelie" = "#FEA346", "Chinstrap" = "#B251F1", "Gentoo" = "#4BA4A4")) +
        scale_shape_manual(values = c("Adelie" = 19, "Chinstrap" = 17, "Gentoo" = 15)) +
        labs(x = "Flipper length (mm)", y = "Bill length (mm)", 
             color = "Penguin species", shape = "Penguin species") + 
        theme_minimal() + 
        theme(legend.position = c(0.85, 0.2), 
              legend.background = element_rect(color = "white")) 
  }) 
```

---

##  {#non-reactive-plot data-menu-title="Non-reactive plot appears"}

[A non-reactive plot now lives in our `plotOutput()` placeholder]{.slide-title-smaller}

<hr>

<p class="body-text bottombr">We have a plot (yay!), but it isn't reactive. We have not yet told the server how to update the plot based on user inputs via the `sliderInput()` in the UI. Let's do that next...</p>

<center><img src="images/nonreactive_app.gif" alt="A user changes the sliderInput meant associated with the penguin data scatterplot, but the plot does not update (i.e. it is not yet reactive)." width="450"/></center>

---

##  {#practice-filtering data-menu-title="Practice filtering data"}

[Practice filtering data in our separate script]{.slide-title-smaller}

<hr>

<p class="small-text">First, create a new data frame where we filter the `body_mass_g` column for observations within a specific range of values (in this example, values ranging from 3000 - 4000):</p>

. . . 

```{r}
#| eval: true
#| echo: true
# load packages
library(palmerpenguins)
library(tidyverse)

# filter penguins df for observations where body_mass_g >= 3000 & <= 4000
body_mass_df <- penguins |> 
  filter(body_mass_g %in% 3000:4000)
```

. . .

<p class="small-text">Then, plot the new filtered data frame:</p>

:::: {.columns}

:::{.column width="55%"}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "2"

# plot new, filtered data
ggplot(na.omit(body_mass_df), # plot 'body_mass_df' rather than 'penguins' df
       aes(x = flipper_length_mm, y = bill_length_mm, 
           color = species, shape = species)) +
  geom_point() +
  scale_color_manual(values = c("Adelie" = "#FEA346", "Chinstrap" = "#B251F1", "Gentoo" = "#4BA4A4")) +
  scale_shape_manual(values = c("Adelie" = 19, "Chinstrap" = 17, "Gentoo" = 15)) +
  labs(x = "Flipper length (mm)", y = "Bill length (mm)", 
       color = "Penguin species", shape = "Penguin species") +
  theme_minimal() +
  theme(legend.position = c(0.85, 0.2),
        legend.background = element_rect(color = "white"))
```
:::

::: {.column width="5%"}
:::

::: {.column width="35%"}
<center><img src="images/filtered_penguin_plot.png" alt="A scatterplot of penguin Bill length (mm) vs. Flipper length (mm) for Adelie (orange circles), Chinstrap (purple triangles), and Gentoo (green squares) penguins. For all species, bill length tends to increase with flipper length." width="450"/></center>
:::

::::

---

##  {#what-needs-updating data-menu-title="What needs to be reactive?"}

[Which part of our code needs to be updated when a user changes the slider range input?]{.slide-title-smaller}

<hr>

. . . 

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "2"
body_mass_df <- penguins |> 
  filter(body_mass_g %in% 3000:4000) # 3000:4000 needs to be update-able (or in other words, reactive)!
```

. . . 

<p class="body-text">**For example:**</p>

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
body_mass_df <- penguins |> 
  filter(body_mass_g %in% 2857:5903)
```

<center><img src="images/2857_5903.png" alt="Our Shiny app with just a title, subtitle, and slider input, where the input values are at a minimum of 2,857 and a maximum of 5,903." width="450"/></center>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
body_mass_df <- penguins |> 
  filter(body_mass_g %in% 3725:5191)
```

<center><img src="images/3725_5191.png" alt="Our Shiny app with just a title, subtitle, and slider input, where the input values are at a minimum of 3,725 and a maximum of 5,191." width="450"/></center>
:::

::::

---

##  {#rule3.1 data-menu-title="Rule #3a"}

[**Rule 3:** Access input values with `input$<id>`]{.slide-title-smaller}

<hr>

<p class="small-text">Recall that in our **UI**, we gave our `sliderInput()` an `inputId = "body_mass_input"`.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "9"

# load packages (omitted for brevity) ----

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):", 
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot")
  
)

# server instructions ----
server <- function(input, output) {
      
  # render the scatter plot ----
  output$bodyMass_scatterPlot <- renderPlot({ 
      ggplot(na.omit(penguins, aes(...)) + # etc. (omitted for brevity)
  }) 
    
}
```

---

##  {#rule3.2 data-menu-title="Rule #3b"}

[**Rule 3:** Access input values with `input$<id>`]{.slide-title-smallest}

<hr>

<p class="smaller-text">In our server, we can access the values of that slider input using the syntax, `input$body_mass_input`. *If you want your output to change according to the input values, substitute hard-coded values (e.g. 3725:5191) with the input values from the UI (e.g. `input$body_mass_input[1]:input$body_mass_input[2]`)*.</p>

<p class="smaller-text important-text-bg">**Importantly**, we need to use `reactive()` to create reactive data frames that update with user inputs. When you call your reactive data frame in your ggplot, **the data frame name must be followed by `()`**.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "20-24|28"

# load packages (omitted for brevity) ----

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g):", 
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot")
  
)

# server instructions ----
server <- function(input, output) {
  
  # filter body masses ----
  body_mass_df <- reactive({ 
    penguins |> 
      filter(body_mass_g %in% input$body_mass_input[1]:input$body_mass_input[2]) 
  })
      
  # render the scatter plot ----
  output$bodyMass_scatterPlot <- renderPlot({ 
      ggplot(na.omit(body_mass_df(), aes(...)) + # etc. (omitted for brevity)
  }) 
    
}
```

---

##  {#run-that-app data-menu-title="Run that app!"}

[Okay, RUN THAT APP!]{.slide-title}

<hr>

<p class="body-text">You should now have a reactive Shiny app! *Note that reactivity automatically occurs whenever you use an **input value** to **render** an **output object**.*</p>

<center><img src="images/reactive_app_v1.gif" alt="A gif of our current Shiny app, demonstrating reactivity. At the top left of our app is the title, 'My App Title' in large header font. Beneath it is a subtitle, 'Exploring Antarctic Penguins and Temperatures'. Below the subtitle is the slider input with the label, 'Select a range of body masses (g)'. A gray horizontal slider bar ranges from the values 2,700 to 6,300. The interactive slider value selectors are two round white circles, which, when moved apart from one another highlight the selected value range in blue. The user is adjusting the slider value selectors and the scatterplot of penguin bill length (mm) vs. flipper length (mm) is automatically updating." width="550"/></center>

---

##  {#recapp-app1 data-menu-title="Recap: app #1"}

[Recap: We created our first *reactive* Shiny app following these steps:]{.slide-title-smallest}

<hr>

. . . 

<p class="body-text">**1.** We created an `app.R` file in it's own directory and began our app with the [template](https://ucsb-meds.github.io/EDS430-Shiny/#/single-file), though you can also create a [two-file Shiny app](https://ucsb-meds.github.io/EDS430-Shiny/#/two-file) by using separate `ui.R` and `server.R` files.</p>

. . .

<p class="body-text topbr">**2.** We added an input to the `fluidPage()` in our **UI** using an `*Input()` function and gave it a *unique* `inputId` (e.g. `inputId = "unique_input_Id_name"`)</p>

. . . 

<p class="body-text topbr">**3.** We created a placeholder for our reactive object by using an `*Output()` function in the `fluidPage()` of our **UI** and gave it an `outputId` (e.g. `outputId = "output_Id_name"`)</p>

. . .

<p class="body-text topbr">**4.** We wrote the **server** instructions for how to assemble inputs into outputs, following these rules:</p>

<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} save objects that you want to display to `output$<id>`</p>
<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} build reactive objects using a `render*()` function (and similarly, build reactive data frames using `reactive()`</p>
<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} access input values with `input$<id>`</p>

. . . 

<center><p class="body-text teal-text">And we saw that reactivity automatically occurs whenever we use an ***input value*** to ***render*** an ***output object***.</p></center>

---

##  {#app1-ex1 data-menu-title="** Exercise 1 Prompt **"}

[`r fontawesome::fa("question", fill = "#05859B", a11y = "sem")` Exercise 1: Add another reactive widget]{.slide-title-smaller}

<hr>

<p class="small-text bottombr"> The [`{DT}` package](https://rstudio.github.io/DT/) provides an R interface to the JavaScript library [DataTables](https://datatables.net/) (you may have already used the DT package in your knitted RMarkdown/Quarto HTML documents). DT datatables allow for filtering, pagination, sorting, and lots of other neat features for tables on your HTML pages.</p>

:::: {.columns}

::: {.column width="45%"}
<br>
<p class="small-text topbr">**Working alone or in groups, add a reactive `DT` datatable to your app with a `checkboxGroupInput` that allows users to select which year(s) to include in the table. Configure your `checkboxGroupInput` so that the years 2007 and 2008 are pre-selected.**</p>
<p class="small-text topbr">In the end, your app should look something like the example to the right.</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/DT.gif" alt="A gif of our current Shiny app, demonstrating the newly added DT::datatable. The user is able to select which years (2007, 2008, 2009) to display data for by clicking on one more more checkboxes." width="550"/></center>
:::

::::

<br>

<center><p class="large-body-text">See next slide for some tips on getting started!</p></center>

---

##  {#app1-ex1-tips data-menu-title="** Exercise 1 Tips **"}

[`r fontawesome::fa("lightbulb", fill = "#05859B", a11y = "sem")` Exercise 1: Tips]{.slide-title-smallest}

<hr>

<p class="body-text topbr">**Tips:**</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} Use `?checkboxGroupInput` to learn more about which arguments you need (remember, all inputs require an `inputId` and oftentimes a `label`, but there are others required to make this work as well)</p>
<p class="smaller-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} Both `{shiny}` and `{DT}` packages have functions named `dataTableOutput()` and `renderDataTable()` -- `DT::renderDataTable()` allows you to create both server-side and client-side DataTables and supports additional DataTables features while `shiny::renderDataTable()` only provides server-side DataTables. Be sure to use the one from the `{DT}` package using the syntax `packageName::functionName()`.</p>
<p class="smaller-text bottombr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} There are lots of ways to customize DT tables, but to create a basic one, all you need is to `DT::dataTable(your_dataframe)`<p>


<p class="body-text topbr">**And remember** to follow the steps outlined on the previous slides (jump back to [slide 27](https://ucsb-meds.github.io/EDS430-Shiny/#/reactive-plot-app1)):</p>

<p class="small-text">**1.** Add an input (e.g. `checkboxGroupInput`) to the **UI** that users can interact with<p>
<p class="small-text">**2.** Add an output (e.g. `DT::datatableOutput`) to the **UI** that creates a placeholder space to fill with our eventual reactive output<p>
<p class="small-text">**3.** Tell the **server** how to assemble inputs into outputs following 3 rules:<p>
<p class="smaller-text">**3.1** Save objects you want to display to `output$<id>`<p>
<p class="smaller-text">**3.2** Build reactive objects using a `render*()` function<p>
<p class="smaller-text">**3.3** Access input values with `input$<id>`<p>

<center><p class="large-body-text topbr">See next slide for a solution!</p></center>

---

##  {#app1-ex1-solution data-menu-title="** Exercise 1 Solution **"}

[{{< fa check title="check mark" >}} Exercise 1: A solution]{.slide-title-smaller}

<hr>

<p class="small-text">Press the right arrow key to advance through the newly added lines of code.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "5|23-29|60-73"
# load packages ----
library(shiny)
library(palmerpenguins)
library(tidyverse)
library(DT)

# user interface ----
ui <- fluidPage(
  
  # app title ----
  tags$h1("My App Title"),
  
  # app subtitle ----
  p(strong("Exploring Antarctic Penguin Data")),
  
  # body mass slider input ----
  sliderInput(inputId = "body_mass_input", label = "Select a range of body masses (g)",
              min = 2700, max = 6300, value = c(3000, 4000)),

  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot"),
  
  # year input ----
  checkboxGroupInput(inputId = "year_input", label = "Select year(s):",
                     choices = c("2007", "2008", "2009"), # or `unique(penguins$year_input)` | NOTE: update checkbox display name by using "New name" = "observation name" (e.g "The year 2007" = "2007")
                     selected = c("2007", "2008")),
  
  # DT output ----
  DT::dataTableOutput(outputId = "penguin_data")
  
)

# server instructions ----
server <- function(input, output) {
  
  # filter body masses ----
  body_mass_df <- reactive({
    penguins |>
      filter(body_mass_g %in% input$body_mass_input[1]:input$body_mass_input[2]) # return observations where body_mass_g is "in" the set of options provided by the user in the sliderInput
  })

  # render the scatterplot output ----
  output$bodyMass_scatterPlot <- renderPlot({

    ggplot(na.omit(body_mass_df()),
           aes(x = flipper_length_mm, y = bill_length_mm,
               color = species, shape = species)) +
      geom_point() +
      scale_color_manual(values = c("Adelie" = "#FEA346", "Chinstrap" = "#B251F1", "Gentoo" = "#4BA4A4")) +
      scale_shape_manual(values = c("Adelie" = 19, "Chinstrap" = 17, "Gentoo" = 15)) +
      labs(x = "Flipper length (mm)", y = "Bill length (mm)",
           color = "Penguin species", shape = "Penguin species") +
      theme_minimal() +
      theme(legend.position = c(0.85, 0.2),
            legend.background = element_rect(color = "white"))
    
  }, alt = "A scatterplot of penguin Bill length (mm) vs. Flipper length (mm) for Adelie (orange circles), Chinstrap (purple triangles), and Gentoo (green squares) penguins."
  )
  
  # filter for years ----
  years_df <- reactive({
    penguins |> 
      filter(year %in% input$year_input) # return observations where year is "in" the set of options provided by the user via the checkboxGroupInput
  })
  
  # render the DT::datatable ----
  output$penguin_data <- DT::renderDataTable({
    
    DT::datatable(years_df(),
                  options = list(pagelength = 10),
                  rownames = FALSE)
    
  })
  
}

# combine UI & server into an app ----
shinyApp(ui = ui, server = server)
```

---

##  {#common-mistakes data-menu-title="Common Mistakes"}

[Common mistakes to look out for]{.slide-title-smaller}

<hr>

<p class="body-text">It's inevitable that you'll make mistakes here and there as you build out your app...and they can be frustrating to catch. A few that I find myself making over and over again are:</p>

<br>

:::: {.columns}

::: {.column width="45%"}
<p class="small-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} misspelling `inputId` as `inputID` (or `outputId` as `outputID`)</p>

<p class="small-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} misspelling your inputId (or outputId) name in the server (e.g. UI: `inputId = "myInputID"`, server: `input$my_Input_ID`)</p>


<p class="small-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} repeating `inputId`s (each *must* be unique)</p>

<p class="small-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} forgetting to separate UI elements with a comma, `,`</p>

<p class="small-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} forgetting the set of parentheses when calling the name of a reactive data frame in a plot (e.g. `ggplot(my_reactive_df(), aes(...))`)</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<br>
<center><img src="images/oops.gif" alt="A gif of Britney Spears in her iconic red spandex outfit singing 'Oops I did it again.'" width="700"/></center>
:::

::::


