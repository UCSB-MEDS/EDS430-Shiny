---
format: revealjs
---

##  {#build-app data-menu-title="Building Out Your 1st App" background="#053660"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">`r fontawesome::fa("tools", fill = "#d2e3f3", a11y = "sem")` Building out your first app</p>
<p class="caption-text">*Here, we'll create our first reactive object and establish a general Shiny coding workflow.*</p>
</div>

---

##  {#roadmap-app1 data-menu-title="Roadmap (app #1)"}

<div class="slide-title bottombr">Roadmap for app #1</div>

<p class="body-text">We'll start by building a small **single-file app** using data from the `{palmerpenguins}` package. We'll build out the the following features:</p>

::: {.column width="45%"}
<br>
<br>

<p class="body-text">**(a)** A title and subtitle</p>

<p class="body-text topbr">**(b)** A slider widget for users to select a range of penguin body masses</p>

<p class="body-text topbr">**(c)** A reactive scatterplot that updates based on user-supplied values</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/reactive_app_v1.gif" alt="A gif of our current Shiny app, demonstrating reactivity. At the top left of our app is the title, 'My App Title' in large header font. Beneath it is a subtitle, 'Exploring Antarctic Penguins and Temperatures'. Below the subtitle is the slider input with the label, 'Select a range of body masses (g)'. A gray horizontal slider bar ranges from the values 2,700 to 6,300. The interactive slider value selectors are two round white circles, which, when moved apart from one another highlight the selected value range in blue. The user is adjusting the slider value selectors and the scatterplot of penguin bill length (mm) vs. flipper length (mm) is automatically updating." width="700"/></center>
:::

---

##  {#adding-text data-menu-title="Adding text"}

<div class="slide-title">Add text in the UI</div>

<p class="small-text">We'll do this in the **UI** within `fluidPage()`, a layout function that sets up the basic visual structure of the page and scales components in real time to fill all available browser width. Add a title and subtitle to your app (be sure to separate each with a comma, `,`), save, and run:</p>

```{r}
#| eval: false
#| echo: true
# user interface ----
ui <- fluidPage(
  
  # app title ----
  "My App Title",
  
  # app subtitle ----
  "Exploring Antarctic Penguins and Temperatures"
  
  )
```

. . . 

<p class="small-text">Recall that the UI is actually just an HTML document. We can style our text by adding static HTML elements using `tags` -- a list of functions that parallel common HTML tags (e.g. `<h1>` == `tags$h1()`) The most common tags also have wrapper functions (e.g. `h1()`).</p>

```{r}
#| eval: false
#| echo: true
# user interface ----
ui <- fluidPage(
  
  # app title ----
  tags$h1("My App Title"), # alternatively, you can use the `h1()` wrapper function
  
  # app subtitle ----
  p(strong("Exploring Antarctic Penguins and Temperatures")) # alternatively, `tags$p(tags$strong("text"))`
  
  )
```

---

##  {#inputs-outputs data-menu-title="Inputs & Outputs"}

<div class="slide-title">What are inputs and outputs?</div>

<p class="small-text">Next, we will begin to add some inputs and outputs to our UI inside `fluidPage()` (anything that you put into `fluidPage()` will appear in our app's user interface...and we want inputs and outputs to show up there!).</p>

<p class="small-text">**Inputs** (or widgets) are the things that users can interact with (e.g. toggle, slide) and provide values to your app. The input functions below correspond to the widgets you see on [slide #9](https://ucsb-meds.github.io/EDS430-Shiny/#/widgets). **Outputs** are the R objects that your user sees (e.g. tables, plots) and are what respond when a user interacts with/changes an input value.</p>

<p class="small-text">The `shiny` package comes with a number of input and output functions, but you can extend these with additional packages (e.g. `shinyWidgets`, `plotly`, `DT`, etc.; more on those later).</p>

::: {.column width="45%"}
<p class="body-text">**Examples of Input Functions:**</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `actionButton()`</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `checkboxInput()`</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `checkboxGroupInput()`</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `dateInput()`</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `dateRangeInput()`</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `radioButtons()`</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `selectInput()`</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `sliderInput()`</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `textInput()`</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` See full list of `shiny` input functions [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson3/)</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<p class="body-text">**Examples of Output Functions:**</p>
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `dataTableOutput()` (inserts an interactive table)</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `imageOutput()` (inserts an image)</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `plotOutput()` (inserts a plot)</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `tableOutput()` (inserts a table)</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` `textOutput()` (inserts text)</p>  
<p class="smaller-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` See full list of `shiny` output functions [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson4/)</p>  
:::
---

##  {#reactive-plot-app1 data-menu-title="Adding reactive plot (app #1)"}

<div class="slide-title">Adding our reactive plot</div>

<p class="small-text">Next, we'll create a **scatterplot of penguin bill lengths vs. penguin flipper lengths** using the `penguins` data set from the `{palmerpengiuns}` package. We will make this scatterplot *reactive* by adding a `sliderInput` that allows users to filter the displayed data points by **selecting a range of penguin body masses** (e.g. only plot bill and flipper lengths for penguins with body masses ranging from 4,500 grams to 6,000 grams).</p>

::: {.column width="45%"}
<br>
<p class="small-text">**To create a reactive plot, we will follow these steps:**</p>
<p class="small-text topbr">**1.** Add an input (e.g. `sliderInput`) to the **UI** that users can interact with</p>
<p class="small-text">**2.** Add an output (e.g. `plotOutput`) to the **UI** that creates a *placeholder space* to fill with our eventual reactive output</p>
<p class="small-text">**3.** Tell the **server** how to assemble inputs into outputs</p>
:::

::: {.column width="5%"}
::: 

::: {.column width="45%"}
<center><img src="images/reactive_app_v1.gif" alt="A gif of our current Shiny app, demonstrating reactivity. At the top left of our app is the title, 'My App Title' in large header font. Beneath it is a subtitle, 'Exploring Antarctic Penguins and Temperatures'. Below the subtitle is the slider input with the label, 'Select a range of body masses (g)'. A gray horizontal slider bar ranges from the values 2,700 to 6,300. The interactive slider value selectors are two round white circles, which, when moved apart from one another highlight the selected value range in blue. The user is adjusting the slider value selectors and the scatterplot of penguin bill length (mm) vs. flipper length (mm) is automatically updating." width="700"/></center>
:::

---

##  {#input-syntax data-menu-title="Input Syntax"}

<div class="slide-title">Input function syntax</div>

<p class="small-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` **All input functions have the same first argument, `inputId`** (**NOTE:** `Id` *not* `ID`), **which is used to connect the front end of your app (the UI) with the back end (the server).** For example, if your UI has an `inputId = "name"`, the server function will access it using the syntax `input$name`. The `inputId` has two constraints: **(1)** it must be a simple string containing only letters, numbers, and underscores, **(2)** it must be unique.</p>

<p class="small-text topbr">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` Most input functions have a second parameter called `label`, which is used to create a human-readable label for the control, which will appear in the UI.</p>

<p class="small-text topbr">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` The remaining arguments are unique to each input function. Oftentimes, these include a `value` parameter, which lets you set the default value of your widget, where applicable.</p>

<p class="body-text topbr">**A couple examples:**</p>
```{r}
#| eval: false
#| echo: true
sliderInput(inputId = "body_mass", label = "Select a range of body masses (g):", value = c(3000, 4000), ...)

selectInput(inputId = "island", label = "Choose and island:", ...)
```

<p class="small-text topbr">Check out the interactive [Shiny Widgets Gallery](https://shiny.rstudio.com/gallery/widget-gallery.html) to learn how to implement the most common widgets.</p>

---

##  {#add-input data-menu-title="Add an Input"}

<div class="slide-title">**Step 1:** Add an input to your app</div>

<p class="body-text">First let's add a `sliderInput()` that will allow users to select a range of penguin body masses (g).</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "6-8"
# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider input ----
  sliderInput(inputId = "body_mass", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000))
  )
```

. . . 

<p class="body-text">When you run your app, you should see something similar to the image below. It's operable, but does not yet have an associated output.</p>

<center><img src="images/3000_4000.png" alt="A basic Shiny app, with a title that says 'My App Title', a subtitle that says, 'Exploring Palmer Penguins and Antarctic Temperatures, and a slider input with a label that says 'Select a range of body masses (g)'. The slider bar has a minimum value of 2,700 and a maximum value of 6,300, and the moveable slider selectors currently range from 3,000 to 4,000." width="450"/></center>

---

##  {#output-syntax data-menu-title="Output Syntax"}

<div class="slide-title">Output function syntax</div>

<p class="body-text">Outputs in the UI create **placeholders** which are later filled by the server function.</p>

<p class="body-text topbr"> Similar to input functions, **all output functions take the same first argument, `outputId`** (again, note `Id` not `ID`), **which connects the front end UI with the back end server.** For example, if your UI contains an output function with an `outputId = "plot"`, the server function will access it (or in other words, know to place the plot in that particular placeholder) using the syntax `output$plot`.</p>

</p>

<p class="body-text topbr">**A couple examples:**</p>
```{r}
#| eval: false
#| echo: true
plotOutput(outputId = "bodyMass_scatterPlot")

dataTableOutput(outputId = "penguin_data")
```

---

##  {#add-output data-menu-title="Add Output"}

<div class="slide-title">**Step 2:** Add an output to your app</div>

<p class="small-text">Let's now add a `plotOutput()` to our app, which will be updated based on the user inputs via the `sliderInput()`.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "10-11"

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider input ----
  sliderInput(inputId = "body_mass", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot ouput ----
  plotOutput(outputId = "bodyMass_scatterPlot")
  
  )
```

. . . 

:::{.column width="45%"}
<br>
<p class="small-text">Okay, it looks like nothing changed?? Remember, `*Output()` functions create placeholders, but we have not yet written the server instructions on how to fill and update those placeholders. We can inspect the HTML and see that there is, in fact, a placeholder area awaiting our eventual output, which will be a plot named "*bodyMass_scatterPlot*":</p>
:::

:::{.column width="5%"}
:::

:::{.column width="45%"}
<center><img src="images/output_placeholder.png" alt="A Google Chrome browser window with our Shiny app open on the left-hand side and the underlying HTML document open on the right. The app looks the same as before, except hovering over the HTML associated with our new plotOutput highlights a blue square region beneath the sliderInput. This highlighted region is the placeholder where our plot will eventually be rendered." width="450"/></center>
:::

---

##  {#rendering-outputs data-menu-title="Rendering outputs"}

<div class="slide-title">Rendering outputs</div>

<p class="body-text">Each `*Output()` function in the UI is coupled with a `render*()` function in the server, which contains the "instructions" for creating the output based on user inputs (or in other words, the instructions for making your output *reactive*).</p>

<center><p class="body-text topbr">**Examples of `*Output()` functions and their corresponding `render*()` functions:**</p></center>

| Output function     | Render function      |
|---------------------|----------------------|
| `dataTableOutput()` | `renderDataTable()`  |  
| `imageOutput()`     | `renderImage()`      |   
| `plotOutput()`      | `renderPlot()`       |  
| `tableOutput()`     | `renderTable()`      |  
| `textOutput()`      | `renderText()`       |  

---

##  {#assemble data-menu-title="Assemble Inputs into Outputs"}

<div class="slide-title">**Step 3:** Tell the server how to assemble inputs into outputs</div>

<p class="small-text">Now that we've designed our input/output in the UI, we need to write the server instructions (i.e. write the server function) on how to actually assemble our input (body mass range via a slider input) into the output (scatter plot).</p>

<p class="small-text">The **server function** is defined with two arguments, `input` and `output`, both of which are list-like objects. You *must* define both of these arguments within the server function. `input` contains the values of all the different inputs at any given time, while `output` is where you'll save output objects to display in the app.</p>

<p class="small-text">***This part can be intimidating, but if you follow these three rules, you will successfully create reactivity within your shiny app!***</p>

<p class="large-body-text">**Rules:**</p>

. . . 

<p class="body-text">**1.** Save objects you want to display to `output$<id>`</p>

<p class="body-text">**2.** Build reactive objects using a `render*()` function</p>

<p class="body-text">**3.** Access input values with `input$<id>`</p>

---

##  {#rule1 data-menu-title="Rule #1"}

<div class="slide-title-smaller">**Rule 1:** Save objects you want to display to `output$<id>`</div>

<p class="small-text">In our **UI**, we created a placeholder for our plot using the `plotOutput()` function and gave it the Id `"bodyMass_scatterplot"`. In our server, we will save our plot to the output argument by its `outputId`:</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "18-19"

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider ----
  sliderInput(inputId = "body_mass", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot") 
  
)

# server instructions ----
server <- function(input, output) {
  
  # render the scatter plot ----
  output$bodyMass_scatterPlot <- # code to generate plot here
  
}
```

<p class="small-text important-text-bg">**Note:** In the **UI**, our `outputId` is quoted (`"bodyMass_scatterPlot"`), but not in the **server** (`bodyMass_scatterPlot`).</p>

---

##  {#rule2 data-menu-title="Rule #2"}

<div class="slide-title-smaller">**Rule 2:** Build reactive objects with `render*()`</div>

<p class="small-text">Use the appropriate `render*()` function to make your output reactive (e.g. if you have a     `plotOutput` in your UI, you will need to use `renderPlot()` in your server).</p>

<p class="small-text">Within your `render*()`, write any code inside a set of curly braces, `{}`. This allows you to include as many lines of code as it takes to build your object.</p>

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "18-23"

# user interface ----
ui <- fluidPage(
  
  # ~ previous code omitted for brevity ~
  
  # body mass slider ----
  sliderInput(inputId = "body_mass", label = "Select a range of body masses (g):",
              min = 2700, max = 6300, value = c(3000, 4000)),
  
  # body mass plot output ----
  plotOutput(outputId = "bodyMass_scatterPlot") 
  
)

# server instructions ----
server <- function(input, output) {
  
  # render the scatter plot ----
  output$bodyMass_scatterPlot <- renderPlot({
    
     # code to generate plot here
    
  }) 
}
```

---

---

##  {#rule3 data-menu-title="Rule #3"}

<div class="slide-title-smaller">**Rule 3:** Access input values with `input$<id>`</div>

