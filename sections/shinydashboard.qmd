---
format: revealjs
---

##  {#building-dashboards data-menu-title="Building Dashboards" background="#053660"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">`r fontawesome::fa("gauge", fill = "#d2e3f3", a11y = "sem")` Building dashboards with `{shinydashboard}`</p>
<p class="caption-text">*`{shiny}` alone is powerful and flexible, however it can take a lot of work to create a sleek/modern UI. `{shinydashboard}` provides a "template" for quickly building visually appeally dashboard apps.*</p>
</div>

---

##  {#LO-app3 data-menu-title="Learning Objectives App #3"}

<div class="slide-title">`r fontawesome::fa("book-open", fill = "#05859B", a11y = "sem")` Learning Objectives for App #3 (shinydashboard)</div>

<p class="medium-body-text bottombr">After this section, you should:</p>

. . . 

<p class="small-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` understand the general workflow for pre-processing, saving & reading data into an app</p>

. . . 

<p class="small-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` be comfortable building out a dashboard UI using `{shinydashboard}` layout functions</p>

. . . 

<p class="small-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` understand how to add static images to your app</p>

. . . 

<p class="small-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` feel comfortable creating a basic reactive `leaflet` map</p>

. . . 

<p class="medium-body-text topbr">New packages used:</p> 

. . .

<p class="small-text">`r fontawesome::fa("box-open", fill = "#05859B", a11y = "sem")` `{shinydashboard}`: provides an alternative UI framework for easily building dashboard-style shiny applications</p>

. . . 

<p class="small-text">`r fontawesome::fa("box-open", fill = "#05859B", a11y = "sem")` `{leaflet}`: for building interactive maps</p>

---

##  {#roadmap-dashboard data-menu-title="Roadmap App #3"}

<div class="slide-title">Roadmap for App #3</div>

<p class="body-text">In this section, we'll be building a **shinydashboard** using data downloaded from the [Arctic Data Center](). We'll be building out the following features:</p>

<br>

:::: {.columns}

::: {.column width="45%"}

<br>

<p class="small-text">**(a)** a `dashboardHeader` with the name of your app</p>
<p class="small-text">**(b)** a `dashboardSidebar` with ___ `menuItem`s</p>
<p class="small-text">**(c)** a landing page with background information about your app</p>
<p class="small-text">**(d)** an interactive *and* reactive `leaflet` map</p>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<!-- <center><img src="images/shinydashboard.gif" alt="" width="750"/></center> -->
:::

::::

---

##  {#begin-with-data data-menu-title="Begin with Data"}

<div class="slide-title">As always, let's start with the data</div>

<p class="body-text bottombr">Building an app doesn't make much sense if we don't know what we're going to put in it. So, just like the last two apps, we'll start with some data wrangling and practice data visualization.</p>

<p class="body-text bottombr">*Unlike* our last two apps, however, we'll be working with tabular data from the [Arctic Data Center](https://arcticdata.io/), which we'll download, process, save, then finally, read into our application. This process will likely be more similar to what you'll encounter when working on your own applications moving forward. **Take a few minutes to review the metadata record for the following data set:**</p>

:::: {.columns}

::: {.column width="45%"}

<br> 

<center><p class="small-text bottombr">Christopher Arp, Matthew Whitman, Katie Drew, and Allen Bondurant. 2022. Water depth, surface elevation, and water temperature of lakes in the Fish Creek Watershed in northern Alaska, USA, 2011-2022. Arctic Data Center. [doi:10.18739/A2JH3D41P](doi:10.18739/A2JH3D41P).</p></center>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/adc_logo.png" alt="The NSF Arctic Data Center Logo, which is a drawing depicting a blue mountain scape with green Northern Lights overhead." width="750"/></center>
:::

::::

---

##  {#processing-storing-data data-menu-title="Processing & Storing Data"}

<div class="slide-title-smaller">Pre-processing data is critical</div>

<p class="small-text">Where you choose to store the data used by your Shiny app will depend largely on the type and size of the file(s) and who "owns" those data. It is likely that you'll be working with data stored in a database or on a server. This is outside the scope of this workshop, but I suggest reading Dean Attali's article, [Persistent data storage in Shiny apps](https://shiny.rstudio.com/articles/persistent-data-storage.html) to start. Because we are going to be working with a relatively small data set, we'll be downloading and storing our data locally (i.e. on our machines and in our GitHub repo).</p>

<p class="small-text topbr">Regardless of where you choose to store your data, you can help your application more quickly process inputs/outputs by providing it *only as much data as needed to run*. This means **pre-processing** your data.</p>

. . . 

:::: {.columns}

::: {.column width="35%"}
<p class="smaller-text topbr">[`FCWO_lakemonitoringdata_2011_2022_daily.csv`](https://arcticdata.io/metacat/d1/mn/v2/object/urn%3Auuid%3A73800a2e-7617-470a-83aa-b530a01f32e3) contains **8 attributes** (variables) and **18,894 observations** collected from a set of **11 lakes** located in the Fish Creek Watershed in northern Alaska between 2011-2022. We'll download and save the file to a `raw_data/` folder in the root directory of our repository. We'll then pre-process the data in a separate script saved to `R/` and save a cleaned/processed version of the data to our app's directory, `/shinydashboard/data/lake_data_processed.csv`. Your repository structure should look similar to example on the right:</p>
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
<center><img src="images/shinydashboard-directory-structure.png" alt="A schematic of the repository structure, as described." width="450"/></center>
:::

::::

---

##  {#lake-data-goal data-menu-title="Lake Data End Goal"}

<div class="slide-title">The Goal:</div>

:::: {.columns}

::: {.column width="45%"}
<center><img src="images/leaflet.gif" alt="An interactive leaflet map with 11 markers placed on different lakes throughout Northeast Alaska. Clicking on a marker reveals details about the lake including the name, elevation, average depth, and average lake bed temperature." width="750"/></center>
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<p class="body-text bottombr">Our goal is to create a `leaflet` map with makers denoting each of the 11 unique lakes where data were collected. When clicked, a marker should reveal the **lake name**, **elevation** (in meters, above sea level), **average depth** of the lake (in meters), and **average lake bed temperature** (in degrees Celsius). *To do so, we'll need a data frame that looks like the example below:*</p>

<img src="images/lakes_df.png" alt="An example of our desired final data frame, with 6 attributes (Site, Latitude, Longitude, Elevation, AvgDepth, AvgTemp) and 11 rows of observations, one for each lake surveyed." width="550"/>
:::

::::

---

##  {#process-lake-data data-menu-title="Process Lake Data"}

<div class="slide-title-smaller">Process lake data & save new file</div>

<p class="small-text important-text-bg">**NOTE:** In this example exercise, I've removed all rows with missing values (i.e. `NaN`s in the `Depth` column & `NA`s in the `BedTemperature` column) before calculating averages. *This is NOT good practice -- exploring and thinking critically about missing data is an important part of data analysis, and in a real-life scenario, you should consider the most appropriate method for handling them.*</p>

```{r}
#| eval: false
#| echo: true
#....................SETUP & DATA PROCESSING.....................

# load packages ----
library(tidyverse)
library(leaflet)

# read in raw data ----
lake_monitoring_data <- read_csv(here::here("raw_data", "FCWO_lakemonitoringdata_2011_2022_daily.csv"))

# calculate avg depth & temp ----
avg_depth_temp <- lake_monitoring_data |> 
  select(Site, Depth, BedTemperature) |> 
  filter(Depth != "NaN") |>  # remove NaN (missing data) from Depth
  drop_na(BedTemperature) |> # remove NAs (missing data) from BedTemperature
  group_by(Site) |> 
  summarize(
    AvgDepth = round(mean(Depth), 1),
    AvgTemp = round(mean(BedTemperature), 1)
  )

# join avg depth & temp to original data (match rows based on 'Site') ---
lake_monitoring_data <- full_join(lake_monitoring_data, avg_depth_temp)

# get unique lakes observations (with corresponding lat, lon, elev, avgDepth, avgTemp) for mapping ----
unique_lakes <- lake_monitoring_data |> 
  select(Site, Latitude, Longitude, Elevation, AvgDepth, AvgTemp) |> 
  distinct()

# save processed data to your app's data directory ----
write_csv(here::here("shinydashboard", "data", "lake_data_processed.csv"))
```

---

##  {#file-types data-menu-title="File Types"}

<div class="slide-title-smaller">A note on file types</div>

<p class="small-text">If you are working with tabular data (as we are in this example), you may choose to save your processed data frame as a `.rds` file (R's own data file format which stores a single R object). Not only are `.rds` file are relatively small (and therefore take up little storage space), but they also preserve data types and classes (e.g. factors and dates), eliminating the need to redefine data types after loading the file.</p>

---

##  {#draft-leaflet data-menu-title="Draft Leaflet"}

<div class="slide-title-smaller">Draft `leaflet` map</div>

<p class="small-text">There are lots of ways to customize `leaflet` maps. We'll be keeping ours relatively simple, but check out the [Leaflet for R](https://rstudio.github.io/leaflet/) documentation for more ways to get creative with your maps.</p>

::: {.panel-tabset}

## leaflet map
```{r}
#| eval: true
#| echo: false

# load packages ----
library(tidyverse)
library(leaflet)

# read in data ----
filtered_lakes <- read_csv(here::here("data", "lake_data_processed.csv"))

# map it ----
map <- leaflet() |> 
  
  # add map tiles (basemap) 
  addProviderTiles("Esri.WorldImagery", # choose tiles that make sense for what you want to highlight
                   options = providerTileOptions(maxNativeZoom = 19, maxZoom = 100)) |> 
  
  # add mini map 
  addMiniMap(toggleDisplay = TRUE, minimized = FALSE) |> 
  
  # set view over AK
  setView(lng = -152.048442, lat = 70.249234, zoom = 6) |> 
  
  # add markers
  addMarkers(data = filtered_lakes,
             lng = filtered_lakes$Longitude, lat = filtered_lakes$Latitude,
             popup = paste("Site Name:", filtered_lakes$Site, "<br>",
                           "Elevation:", filtered_lakes$Elevation, "meters (above SL)", "<br>",
                           "Avg Depth:", filtered_lakes$AvgDepth, "meters", "<br>",
                           "Avg Lake Bed Temperature:", filtered_lakes$AvgTemp, "deg Celsius"))

map
```

## code

```{r}
#| eval: false
#| echo: true
#....................SETUP & DATA PROCESSING.....................

# omitted for brevity (see slide 112 for code)

#..........................PRACTICE VIZ..........................

leaflet() |> 
  
  # add tiles
  addProviderTiles("Esri.WorldImagery", # make note of using appropriate tiles
                   options = providerTileOptions(maxNativeZoom = 19, maxZoom = 100)) |> 
  
  # add mini map
  addMiniMap(toggleDisplay = TRUE, minimized = TRUE) |> 
  
  # set view over AK
  setView(lng = -152.048442, lat = 70.249234, zoom = 6) |> 
  
  # add markers
  addMarkers(data =  unique_lakes,
             lng = unique_lakes$Longitude, lat = unique_lakes$Latitude,
             popup = paste("Site Name:", unique_lakes$Site, "<br>",
                           "Elevation:", unique_lakes$Elevation, "meters (above SL)", "<br>",
                           "Avg Depth:", unique_lakes$AvgDepth, "meters", "<br>",
                           "Avg Lake Bed Temperature:", unique_lakes$AvgTemp, "deg Celsius"))
```

:::

---

##  {#filter-leaflet data-menu-title="Filter Leaflet"}

<div class="slide-title-smaller">Practice filtering `leaflet` observations</div>

<p class="small-text">We'll eventually build three `sliderInput`s to filter lake makers by `Elevation`, `AvgDepth`, and `AvgTemp`. Practice filtering here first (and be sure to update the data frame name in your leaflet code!):</p>

::: {.panel-tabset}

## leaflet map (filtered)
```{r}
#| eval: true
#| echo: false
#....................SETUP & DATA PROCESSING.....................

# load packages ----
library(tidyverse)
library(leaflet)

# read in data ----
lakes_cleaned <- read_csv(here::here("data", "lake_data_processed.csv"))

#.......................PRACTICE FILTERING.......................
filtered_lakes <- lakes_cleaned |> 
  filter(Elevation >= 8 & Elevation <= 20) |> 
  filter(AvgDepth >= 2 & AvgDepth <= 3) |> 
  filter(AvgTemp >= 4 & AvgTemp <= 6)

#..........................PRACTICE VIZ..........................
map <- leaflet() |> 
  
  # add map tiles (basemap) 
  addProviderTiles("Esri.WorldImagery", # choose tiles that make sense for what you want to highlight
                   options = providerTileOptions(maxNativeZoom = 19, maxZoom = 100)) |> 
  
  # add mini map 
  addMiniMap(toggleDisplay = TRUE, minimized = FALSE) |> 
  
  # set view over AK
  setView(lng = -152.048442, lat = 70.249234, zoom = 6) |> 
  
  # add markers
  addMarkers(data = filtered_lakes,
             lng = filtered_lakes$Longitude, lat = filtered_lakes$Latitude,
             popup = paste("Site Name:", filtered_lakes$Site, "<br>",
                           "Elevation:", filtered_lakes$Elevation, "meters (above SL)", "<br>",
                           "Avg Depth:", filtered_lakes$AvgDepth, "meters", "<br>",
                           "Avg Lake Bed Temperature:", filtered_lakes$AvgTemp, "deg Celsius"))

map
```

## code

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "5-10|26-32"
#....................SETUP & DATA PROCESSING.....................

# omitted for brevity (see slide 112 for code)

#.......................PRACTICE FILTERING.......................

filtered_lakes <- unique_lakes |> 
  filter(Elevation >= 8 & Elevation <= 20) |> 
  filter(AvgDepth >= 2 & AvgDepth <= 3) |> 
  filter(AvgTemp >= 4 & AvgTemp <= 6)

#..........................PRACTICE VIZ..........................

leaflet() |> 
  
  # add tiles
  addProviderTiles("Esri.WorldImagery", # make note of using appropriate tiles
                   options = providerTileOptions(maxNativeZoom = 19, maxZoom = 100)) |> 
  
  # add mini map
  addMiniMap(toggleDisplay = TRUE, minimized = TRUE) |> 
  
  # set view over AK
  setView(lng = -152.048442, lat = 70.249234, zoom = 6) |> 
  
  # add markers
  addMarkers(data =  filtered_lakes,
             lng = filtered_lakes$Longitude, lat = filtered_lakes$Latitude,
             popup = paste("Site Name:", filtered_lakes$Site, "<br>",
                           "Elevation:", filtered_lakes$Elevation, "meters (above SL)", "<br>",
                           "Avg Depth:", filtered_lakes$AvgDepth, "meters", "<br>",
                           "Avg Lake Bed Temperature:", filtered_lakes$AvgTemp, "deg Celsius"))
```
:::

---

##  {#dashboardPage data-menu-title="dashboardPage()"}

<div class="slide-title-smaller">The most basic shinydashboard is made up of a header, a sidebar, and a body</div>

<p class="small-text">The main difference between a **shiny app** and a **shinydashboard** are the UI elements. Rather than a `fluidPage()` (as used in our previous shiny apps), we'll create a `dashboardPage()`, which expects three main parts: a header, a sidebar, and a body. Below is the most minimal possible UI for a `{shinydashboard}` page (you can run this code in an `app.R` file, if you wish).</p>

:::: {.columns}

::: {.column width="45%"}
```{r}
#| eval: false
#| echo: true
#..............................setup.............................
library(shiny)
library(shinydashboard)

#...............................ui...............................
ui <- dashboardPage(
  
  dashboardHeader(), 
  dashboardSidebar(), 
  dashboardBody() 
  
) 

#.............................server.............................
server <- function(input, output) {}

#......................combine ui & server.......................
shinyApp(ui, server)
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
<center><img src="images/basic_dashboard.png" alt="The most basic shinydashboard UI, with the default coloring -- a dashboardHeader in light blue, a dashboardSidebar in dark blue, and a dashboardBody in off-white." width="750"/></center>
:::

::::

---

##  {#shinydashboard-examples data-menu-title="Examples of shinydashboards"}

<div class="slide-title bottombr">Example shiny dashboards built by some familiar folks `r fontawesome::fa("face-smile", fill = "#05859B", a11y = "sem")`</div>

<p class="small-text">`r fontawesome::fa("school", fill = "#05859B", a11y = "sem")` [Bren Student Data Explorer](https://shinyapps.bren.ucsb.edu/student-data-explorer/) ([**source code**](https://github.com/UCSB-MEDS/shiny-dashboard)), *by MEDS 2022 alum, [Halina Do-Linh](https://www.linkedin.com/in/halinadolinh/), during her Bren Summer Fellowship (and continued by future MEDS students!)* -- explore Bren school student demographics and career outcomes</p>

<p class="small-text topbr">`r fontawesome::fa("person-hiking", fill = "#05859B", a11y = "sem")` [Sam's Strava Stats](https://samanthacsik.shinyapps.io/strava_dashboard/) ([**source code**](https://github.com/samanthacsik/strava-dashboard)), *by yours truly, [Sam Csik](https://samanthacsik.github.io/)* -- a new and ongoing side project exploring my Strava hiking/biking/walking data</p>

<p class="small-text topbr">`r fontawesome::fa("fish", fill = "#05859B", a11y = "sem")` [Channel Islands National Park's Kelp Forest Monitoring Program](http://34.94.133.101/) ([**source code**](https://github.com/cullen-molitor/KFM_Shiny_App)), *by MEDS 2022 alum, [Cullen Molitor](https://cullen-molitor.github.io/)* -- explore subtidal monitoring data collected from our closest National Park</p>

<p class="small-text topbr">`r fontawesome::fa("campground", fill = "#05859B", a11y = "sem")` [The Outdoor Equity App](https://shinyapps.bren.ucsb.edu/oe_app/) ([**source code**](https://github.com/outdoor-equity/outdoor-equity)), *developed by MEDS 2022 alumni [Halina Do-Linh](https://www.linkedin.com/in/halinadolinh/) & [Clarissa Boyajian](https://cboyajian.github.io/) as part of their MEDS capstone project* -- analyze patterns in the access and demand of visitors at reservable overnight sites</p>

<p class="small-text topbr">`r fontawesome::fa("sun", fill = "#05859B", a11y = "sem")` [Energy Siting Dashboard](https://energysiting.github.io/energysiting-dashboard/) ([**source code**](https://github.com/energysiting/energysiting-dashboard)), *developed by MEDS 2022 alumni [Paloma Cartwright](https://palomacartwright.github.io/), [Joe DeCesaro](https://joedecesaro.github.io/), [Daniel Kerstan](https://www.linkedin.com/in/daniel-kerstan-5b162321b/) & [Desik Somasundaram](https://www.linkedin.com/in/desik-somasundaram-902a8a120/) as part of their MEDS capstone project* -- explore predictions of the most suitable locations for large, utility-scale wind and solar projects across the United States</p>



